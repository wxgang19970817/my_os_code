# 7_中断

## 中断是什么？为什么要有中断？

### 中断

- 概念：由于CPU获知了计算机中发生的某些事，CPU暂停正在执行的程序，转而去执行处理该事件的程序，当这段程序执行完毕后，CPU继续执行刚才的程序，整个过程称为中断处理，即中断

### 并发和并行

- 并发：指的是单位时间内的累计工作量，比如每秒并发数是100,这是指一秒内累计的请求量总和为100个请求
- 并行：指的是真正同时进行的工作量，比如并行100个请求量指的是任意瞬间都有100个请求发生
- **单核CPU谈并发，多核CPU谈并行**

### 操作系统是中断驱动

- 本身操作系统是一个死循环，否则CPU会执行到不知何处，也许会因为执行到不能识别的地方，因指令解码失败而抛出UD异常(未定义操作码、无效操作码)

## 中断分类

### 外部中断

- 外部中断是指CPU外部的中断，而外部中断必须是某个硬件，所以外部中断又称为硬件中断
- 外部中断按是否导致宕机来划分，可分为可屏蔽中断和不可屏蔽中断
- 为了让CPU获得每个外部设备的中断信息，最好的方式是在CPU中为每一个外设准备一个引脚接收中断，但是这是不可能的。一种可行的方案是CPU提供统一的接口作为中断信号的公共线路，所有来自外设的中断信号都是共享公共线路连接到CPU.
- CPU提供了两条信号线，外部硬件的中断是通过两根信号线INTR(INTeRrupt)和NMI(Non Maskable Interrupt)来通知CPU的

#### 可屏蔽中断

- 可屏蔽中断是通过INTR信号线进入CPU的
- 此类中断一般是由外部设备，如硬盘、网卡等发出的，不会导致宕机，CPU可以随时处理，甚至不理会，或者像Linux一样将中断分为上下部分分开处理
- 此类中断可以通过eflags寄存器的IF位将所有这些外部设备的中断屏蔽
- 可屏蔽中断数量有限，每一种中断源都可以获得一个中断向量号，这个整数用于在中断向量表或中断描述符表中索引对应的中断处理程序并去执行

#### 不可屏蔽中断

- 不可屏蔽中断是通过NMI信号线进入CPU的
- 此类中断一般是电源掉电，内存读写错误，总线奇偶校验错误等
- 此类中断一旦发生，无法屏蔽，必须进行处理
- 不可屏蔽中断一般来说不需要从软件上细分原因，统统为导致宕机的各种原因分配一个中断向量号2就够了

#### 中断处理程序的上下部分

- 一般把中断处理程序中需要理解执行的部分划到上半部通常情况下只完成中断应答或硬件复位等重要紧迫的工作，所以上半部分都是在关中断的情况下处理的
- 而中断处理程序中那些不紧急的部分则推迟到下半部中去完成，所以下半部是在开中断的情况下完成的，如果有新的中断发生，原来的这个旧中断的下半部就会被换下CPU,先执行新的中断处理程序的上半部，等待线程调度机制为旧中断处理程序调度执行

### 内部中断

#### 软中断

- 软中断就是由软件主动发起的中断，所以它是主观上的，并不是客观上的某种内部错误

- 但是因为这是用于实现系统调用功能，因此也不受IF位影响

- 以下是可以发起中断的指令：

  - “int 8位立即数”。这是用来进行系统调用的，8位立即数可表示256种中断，和处理器所支持的中断数是吻合的
  - “int3”（int和3之间不能有空格），断点调试指令触发的是中断向量号3
    - **GDB或bochs调试的原理**：我们进行调试实际上就是调试器fork了一个子进程，子进程用于运行被调试的程序。int3指令的机器码是0xcc,断点本质上是指令的地址，调试器(父进程)将被调试进程(子进程)断点起始地址的第1个字节备份好之后，在原地将该指令的第1字节修改为0xcc，这样指令在执行到断点处，会去执行机器码为0xcc的int3指令，该指令会触发3号中断，从而会去执行3号中断对应的中断处理程序，由于中断处理程序在执行的时候也要用到寄存器，为了保存所调试进程的现场，该中断程序必须先将当前的寄存器和相关内单元压栈保存(当前寄存器和相关内存都属于那个被调试的进程)，**用户在查看寄存器和变量时就是从栈中获取的**。当恢复执行所调试的程序时，中断处理程序需要将之前备份的1字节还原至断点处，然后恢复各寄存器和内存单元的值，修改返回地址为断点地址，用iret指令退出中断，返回到用户进程继续执行。

  - “into”:中断溢出指令
  - “bound”：检查数组索引越界的指令，触发5号中断
  - “ud2”：未定义指令，会触发6号中断

#### 异常

- 异常是指令执行期间，CPU内部产生的错误引起的
- 既然是运行时错误，那么它不受标志寄存器的IF位影响也就很正常了
- 并不是所有异常都致命，按照轻重程度，可以分为以下三种：
  1. Fault,也称为故障，这种错误是可以被修复的一种类型，属于最轻的一种异常。当发生此类异常时CPU将机器状态恢复到异常之前的状态，之后调用中断处理程序时，CPU将返回地址依然指向导致fault异常的那条指令。最典型的例子就是操作系统中常出现的缺页异常page fault
  2. Trap，也称陷阱。通常用在调试中，比如int3指令便引发此类异常，为了让中断处理程序返回后能继续向下执行，CPU将中断处理程序的返回地址指向导致异常指令的下一个指令地址
  3. Abort，也称为终止，这是最严重的类型，一旦出现，由于错误无法修复程序无法继续运行，操作系统会将此程序从进程表中去掉。

### 总述

- CPU不管有多少种类型的中断，为了统一管理，把来自外部设备、内部指令的各种终端类型统统归结为一种管理方式，即为每个中断信号分配一个整数，把此整数作为中断的ID,而这个整数就是所谓的中断向量，然后用此ID作为中断描述符表中的索引，找到对应的表项，进而找到对应的中断处理程序
- 异常和不可屏蔽中断的中断向量号是由CPU自动提供的，而来自外部设备的可屏蔽中断号是中断代理提供的，软中断是软件提供的

## 中断描述符表

#### 中断描述符表和中断向量表的区别

- 中断向量表
  - 实模式下用于存储中断处理程序入口的表叫中断向量表(Interrupt Vector Table)
  - 可容纳256个中断向量，每个向量4字节。
  - 位置固定位于物理内存最低端

- 中断描述符表
  - 保护模式下用于存储中断处理程序入口的表(Interrup Descriptor,IDT)
  - 除了有中断门，还可以有任务门、陷阱门
  - 在CPU内部有一个中断描述符表寄存器IDTR，第0~15位是表界限，第16~47位是IDT的段基址
  - 16位的表界限，就是64KB，每个门描述符的大小是8字节，所以可以容纳8192个描述符，但是处理器只支持256个中断，所以其他都空着了
  - 和全局描述符表不同的是，GDT的第0个描述符不可用，IDT的第0个描述符是可用的

#### 中断处理过程及保护

完整的中断过程分为CPU外和CPU内：

- CPU外:外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU

- CPU内如下：

  1. 处理器根据中断向量号定位中断门描述符

     处理器用中断向量号乘以8后，再与IDTR中的中断描述符表地址相加后，所求得的地址之和便是该中断向量号对应的中断门描述符

  2. 中断发生后，eflags中的NT位(Nested task)和TF(Trap flag)位会被置0，如果中断对应的中断门描述符是中断门，标志寄存器的IF(Interrupt enable flag)位被自动置0，避免中断嵌套

  3. 处理器进行特权检查

     由于中断是通过中断向量号通知到处理器的，它只是个整数，并没有RPL，所以特权级检查并不涉及到RPL。对于软件主动发起的软中断，当前特权级CPL必须在门描述符DPL和中断服务程序所在代码段的DPL之间

  4. 执行中断处理程序

     将门描述符目标代码段选择子加载到代码段寄存器CS中，把门描述符中的中断处理程序的偏移地址加载到EIP，开始执行中断处理程序。如果愿意的话，可以在中断处理程序中将IF位打开，这样便可以根据需要优先处理更高特权级的中断，打开的方法就是利用指令　sti　开中断，cli指令可以关中断。而且前面将TF位指令代表禁止单步执行。

  5. 从中断返回的指令是iret,它从栈中弹出数据到寄存器cs、eip、eflags等，根据特权级判断是否要恢复旧栈。这里有一点就是iret指令有两个作用：一个是从中断返回，一个是返回到调用自己的任务中，这也相当于执行一个任务，它是如何知道是该从中断中返回呢？NT位，任务嵌套标志位，用来标记任务嵌套的情况，置1代表当前任务是被嵌套执行的是有别的任务调用的，而别的任务(旧任务)在调用它的时候，会将自己的TSS选择子写到当前任务TSS的"上一个任务TSS指针"，所以处理器在执行iret指令的时候就会去查看NT位来判断

#### **中断发生时的压栈**

- 在拿到中断处理程序的选择子后加载到CS中，必然会导致段描述符寄存器的刷新
  1. 处理器拿到中断描述符表后，拿CPL和DPL对比，如果发现要向高特权级转变，那就要将旧栈保存起来。所以先将当前旧栈的SS和ESP的值临时保存起来，然后从TSS中找到同目标代码段DPL级别相同的栈加载到寄存器SS和ESP中，再将之前保存的旧栈的SS和ESP的值压入栈中。如果没有涉及到特权级转移，便不会到TSS中寻找新栈
  2. 在新栈中压入EFLAGS寄存器
  3. 由于要切换到目标代码段，对于这种段间转移，要将CS和EIP保存到当前栈汇总备份，以便中断程序执行结束后能恢复到被中断的过程
  4. 某些异常会有错误码，此错误码用于报告异常是发生在哪个段上的
  5. 处理器进入中断执行完中断处理程序后，还要返回到被中断的进程，这是进入中断的逆过程，中断返回是用iret指令实现的，它会依次从栈顶处弹出数据，每次4字节，对号入座弹出到相关寄存器－错误码、EIP、CS、EFLAGS、ESP、SS
  6. 在中断返回的时候会再做一次特权级检查，过程不再赘述。值得注意的是，如果在返回时需要改变特权级，将会检查数据段寄存器DS、ES、FS和GS的内容，如果在它们之中，某个寄存器中选择子所指向的数据段描述符的DPL权限比返回后的CPL高，处理器将把数值0填充到相应的段寄存器，从而故意使处理器抛异常。

## 可编程中断控制器

- 中断控制器的作用就是管理和控制可屏蔽中断，表现在屏蔽外设中断，对它们实行优先级判决，向CPU提供中断向量号等功能

## 编写中断处理程序

### 代码逻辑

- 初上电，对所有模块进行初始化
- 初始化中断：构造中断描述符表，即先将中断门描述符构造好，然后将中断处理程序绑定到中断门描述符中。这里的中断处理程序的框架都一样，先是压入各种需要入栈的数据，然后就是调用在ide_table中注册的C语言中断处理函数，此函数会根据函数号的不一样选择不一样的处理函数，处理完成之后退出
- 所以在初始化完中断后，要完成C语言中断处理函数在ide_table中的注册
- 初始化可编程中断控制器PIC，管理外设的中断

### 零碎知识点

- 在汇编中有多种定义宏的方式，如果是定义单行的宏，可以用%define指令来实现，如果是定义多行的宏，就要用%macro来实现，定义方法是：

  ```assembly
  ％macro 宏名字参数个数
  ....
  宏代码体
  ....
  %endmacro
  ```

  举例如下：

  ```assembly
  %macro mul_add2
  mov eax,%1
  add eax,%2
  %endmacro
  ```

  调用上面代码:mul_add45,24，其中%1就是45，%2就是24

- 中断向量0~19是处理器内部固定的异常类型，20~31是Intel保留的
- 为了提速，在我们的实现中，有的函数增加了inline关键字，它建议处理器将函数编译为内嵌的方式，即将所调用的函数体的内容，在该函数的调用处原封不动地展开，这样编译后的代码不包含call指令，也就不属于函数调用了，而是顺次执行。这虽然会让程序大一些，但减少了函数调用及返回时的现场保护及恢复工作，提升了效率

## 可编程控制器

### 时钟

- 定义：在计算机系统中，为了使所有设备之间的通信井然有序，各通信设备间必须有统一的节奏，不能各干各的，这个节奏就称为定时或时钟

- 时钟并不是计算机处理速度的衡量，而是一种使设备间相互配合而避免发生冲突的节拍。

- 时钟信号并不是专指处理器的时钟，也并不特指IRQ上的时钟，表达的意思仅仅是设备自己的工作节拍、频率

- 计算机的时钟，大致上可分为两类：

  - 内部时钟：处理器中内部元件，如运算器、控制器的工作时序，主要用于控制、同步内部工作过程的步调
    - 内部时钟是由晶体振荡器产生的，简称晶振，位于主板上
    - 晶振的频率经过分频之后就是主板的外频，处理器和南北桥之间的通信就基于外频
    - Intel处理器将此外频乘以某个倍数(也称为倍频)之后便称为主频，处理器取指令、执行指令中所消耗的时钟周期都是基于主频的
    - 内部时钟是由处理器固件结构决定的，在出厂时就设定好了，**无法改变**，处理器内部元件的工作速度是最快的，一般都是纳秒(ns)级别

  - 外部时钟：处理器与外部设备或外部设备之间的通信采用的一种时序，比如IO接口和处理器之间在A/D转换时的工作时序、两个串口设备之间进行数据传输时也要事先同步时钟，一般是毫秒级或秒级
  - 外部时钟和内部时钟是两套独立运行的定时体系，为了保证运行在不同时钟节拍下的设备能够同步通信，就要采用定时器/计时器，当计时器到达了所计数的时间，计时器可以自动发一个输出信号，可以用该信号向处理器发出中断，这样处理器就可以去执行相应的中断处理程序

### 定时器

- 定时器分为可编程定时器和不可编程定时器
- 微信计算机系统中定时功能是必不可少的，比如防止RAM中的数据丢失，每隔一段时间就要对RAM进行充电刷新，或者定时检测某些参数。
- 这里用到定时器的目的就是为了提升时钟中断信号的频率，而时钟中断信号是由计数器0负责产生的，将高频的输入脉冲信号(定时器自身的时钟频率)转换为低频的输出信号，用来产生时钟中断信号。

​		
