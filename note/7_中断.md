# 7_中断

## 中断是什么？为什么要有中断？

### 中断

- 概念：由于CPU获知了计算机中发生的某些事，CPU暂停正在执行的程序，转而去执行处理该事件的程序，当这段程序执行完毕后，CPU继续执行刚才的程序，整个过程称为中断处理，即中断

### 并发和并行

- 并发：指的是单位时间内的累计工作量，比如每秒并发数是100,这是指一秒内累计的请求量总和为100个请求
- 并行：指的是真正同时进行的工作量，比如并行100个请求量指的是任意瞬间都有100个请求发生
- **单核CPU谈并发，多核CPU谈并行**

### 操作系统是中断驱动

- 本身操作系统是一个死循环，否则CPU会执行到不知何处，也许会因为执行到不能识别的地方，因指令解码失败而抛出UD异常(未定义操作码、无效操作码)

## 中断分类

### 外部中断

- 外部中断是指CPU外部的中断，而外部中断必须是某个硬件，所以外部中断又称为硬件中断
- 外部中断按是否导致宕机来划分，可分为可屏蔽中断和不可屏蔽中断
- 为了让CPU获得每个外部设备的中断信息，最好的方式是在CPU中为每一个外设准备一个引脚接收中断，但是这是不可能的。一种可行的方案是CPU提供统一的接口作为中断信号的公共线路，所有来自外设的中断信号都是共享公共线路连接到CPU.
- CPU提供了两条信号线，外部硬件的中断是通过两根信号线INTR(INTeRrupt)和NMI(Non Maskable Interrupt)来通知CPU的

#### 可屏蔽中断

- 可屏蔽中断是通过INTR信号线进入CPU的
- 此类中断一般是由外部设备，如硬盘、网卡等发出的，不会导致宕机，CPU可以随时处理，甚至不理会，或者像Linux一样将中断分为上下部分分开处理
- 此类中断可以通过eflags寄存器的IF位将所有这些外部设备的中断屏蔽
- 可屏蔽中断数量有限，每一种中断源都可以获得一个中断向量号，这个整数用于在中断向量表或中断描述符表中索引对应的中断处理程序并去执行

#### 不可屏蔽中断

- 不可屏蔽中断是通过NMI信号线进入CPU的
- 此类中断一般是电源掉电，内存读写错误，总线奇偶校验错误等
- 此类中断一旦发生，无法屏蔽，必须进行处理
- 不可屏蔽中断一般来说不需要从软件上细分原因，统统为导致宕机的各种原因分配一个中断向量号2就够了

#### 中断处理程序的上下部分

- 一般把中断处理程序中需要理解执行的部分划到上半部通常情况下只完成中断应答或硬件复位等重要紧迫的工作，所以上半部分都是在关中断的情况下处理的
- 而中断处理程序中那些不紧急的部分则推迟到下半部中去完成，所以下半部是在开中断的情况下完成的，如果有新的中断发生，原来的这个旧中断的下半部就会被换下CPU,先执行新的中断处理程序的上半部，等待线程调度机制为旧中断处理程序调度执行

### 内部中断

#### 软中断

- 软中断就是由软件主动发起的中断，所以它是主观上的，并不是客观上的某种内部错误

- 但是因为这是用于实现系统调用功能，因此也不受IF位影响

- 以下是可以发起中断的指令：

  - “int 8位立即数”。这是用来进行系统调用的，8位立即数可表示256种中断，和处理器所支持的中断数是吻合的
  - “int3”（int和3之间不能有空格），断点调试指令触发的是中断向量号3
    - **GDB或bochs调试的原理**：我们进行调试实际上就是调试器fork了一个子进程，子进程用于运行被调试的程序。int3指令的机器码是0xcc,断点本质上是指令的地址，调试器(父进程)将被调试进程(子进程)断点起始地址的第1个字节备份好之后，在原地将该指令的第1字节修改为0xcc，这样指令在执行到断点处，会去执行机器码为0xcc的int3指令，该指令会触发3号中断，从而会去执行3号中断对应的中断处理程序，由于中断处理程序在执行的时候也要用到寄存器，为了保存所调试进程的现场，该中断程序必须先将当前的寄存器和相关内单元压栈保存(当前寄存器和相关内存都属于那个被调试的进程)，**用户在查看寄存器和变量时就是从栈中获取的**。当恢复执行所调试的程序时，中断处理程序需要将之前备份的1字节还原至断点处，然后恢复各寄存器和内存单元的值，修改返回地址为断点地址，用iret指令退出中断，返回到用户进程继续执行。

  - “into”:中断溢出指令
  - “bound”：检查数组索引越界的指令，触发5号中断
  - “ud2”：未定义指令，会触发6号中断

#### 异常

- 异常是指令执行期间，CPU内部产生的错误引起的
- 既然是运行时错误，那么它不受标志寄存器的IF位影响也就很正常了
- 并不是所有异常都致命，按照轻重程度，可以分为以下三种：
  1. Fault,也称为故障，这种错误是可以被修复的一种类型，属于最轻的一种异常。当发生此类异常时CPU将机器状态恢复到异常之前的状态，之后调用中断处理程序时，CPU将返回地址依然指向导致fault异常的那条指令。最典型的例子就是操作系统中常出现的缺页异常page fault
  2. Trap，也称陷阱。通常用在调试中，比如int3指令便引发此类异常，为了让中断处理程序返回后能继续向下执行，CPU将中断处理程序的返回地址指向导致异常指令的下一个指令地址
  3. Abort，也称为终止，这是最严重的类型，一旦出现，由于错误无法修复程序无法继续运行，操作系统会将此程序从进程表中去掉。

### 总述

- CPU不管有多少种类型的中断，为了统一管理，把来自外部设备、内部指令的各种终端类型统统归结为一种管理方式，即为每个中断信号分配一个整数，把此整数作为中断的ID,而这个整数就是所谓的中断向量，然后用此ID作为中断描述符表中的索引，找到对应的表项，进而找到对应的中断处理程序
- 异常和不可屏蔽中断的中断向量号是由CPU自动提供的，而来自外部设备的可屏蔽中断号是中断代理提供的，软中断是软件提供的

## 中断描述符表

#### 中断描述符表和中断向量表的区别

- 中断向量表
  - 实模式下用于存储中断处理程序入口的表叫中断向量表(Interrupt Vector Table)
  - 可容纳256个中断向量，每个向量4字节。
  - 位置固定位于物理内存最低端

- 中断描述符表
  - 保护模式下用于存储中断处理程序入口的表(Interrup Descriptor,IDT)
  - 除了有中断门，还可以有任务门、陷阱门
  - 在CPU内部有一个中断描述符表寄存器IDTR，第0~15位是表界限，第16~47位是IDT的段基址
  - 16位的表界限，就是64KB，每个门描述符的大小是8字节，所以可以容纳8192个描述符，但是处理器只支持256个中断，所以其他都空着了
  - 和全局描述符表不同的是，GDT的第0个描述符不可用，IDT的第0个描述符是可用的

#### 中断处理过程及保护

完整的中断过程分为CPU外和CPU内：

- CPU外:外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU

- CPU内如下：

  1. 处理器根据中断向量号定位中断门描述符

     处理器用中断向量号乘以8后，再与IDTR中的中断描述符表地址相加后，所求得的地址之和便是该中断向量号对应的中断门描述符

  2. 中断发生后，eflags中的NT位(Nested task)和TF(Trap flag)位会被置0，如果中断对应的中断门描述符是中断门，标志寄存器的IF(Interrupt enable flag)位被自动置0，避免中断嵌套

  3. 处理器进行特权检查

     由于中断是通过中断向量号通知到处理器的，它只是个整数，并没有RPL，所以特权级检查并不涉及到RPL。对于软件主动发起的软中断，当前特权级CPL必须在门描述符DPL和中断服务程序所在代码段的DPL之间

  4. 执行中断处理程序

     将门描述符目标代码段选择子加载到代码段寄存器CS中，把门描述符中的中断处理程序的偏移地址加载到EIP，开始执行中断处理程序。如果愿意的话，可以在中断处理程序中将IF位打开，这样便可以根据需要优先处理更高特权级的中断，打开的方法就是利用指令　sti　开中断，cli指令可以关中断。而且前面将TF位指令代表禁止单步执行。

  5. 从中断返回的指令是iret,它从栈中弹出数据到寄存器cs、eip、eflags等，根据特权级判断是否要恢复旧栈。这里有一点就是iret指令有两个作用：一个是从中断返回，一个是返回到调用自己的任务中，这也相当于执行一个任务，它是如何知道是该从中断中返回呢？NT位，任务嵌套标志位，用来标记任务嵌套的情况，置1代表当前任务是被嵌套执行的是有别的任务调用的，而别的任务(旧任务)在调用它的时候，会将自己的TSS选择子写到当前任务TSS的"上一个任务TSS指针"，所以处理器在执行iret指令的时候就会去查看NT位来判断

#### **中断发生时的压栈**

- 在拿到中断处理程序的选择子后加载到CS中，必然会导致段描述符寄存器的刷新
  1. 处理器拿到中断描述符表后，拿CPL和DPL对比，如果发现要向高特权级转变，那就要将旧栈保存起来。所以先将当前旧栈的SS和ESP的值临时保存起来，然后从TSS中找到同目标代码段DPL级别相同的栈加载到寄存器SS和ESP中，再将之前保存的旧栈的SS和ESP的值压入栈中。
  2. 在新栈中压入EFLAGS寄存器
  3. 

