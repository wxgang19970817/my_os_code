# 5_保护模式进阶,向内核迈进

## 获取物理内存

### Linux获取物理内存的方法

- 首先要明确的是获取内存是在进入保护模式之前就要获取到,之后开启分页的内存管理都是建立在物理内存之上的
- 在Linux2.6内核中,是用detect_memory函数来获取内存容量的.其本质上就是通过调用BIOS中断0x15实现的,分别是BIOS中断0x15的三个子功能
- 如果三个方式都失败了,由于无法获取内存信息,后续程序无法加载,只好将机器挂起,停止运行.

## 启用分页机制

### 内存为什么要分页

首先我们来分析一个问题,进入保护模式后,当不开启分页时,多个进程想要同时运行,但是实际的物理内存容量不够怎么办?

- 在前面学习中,有提到过段描述符中有一个P位,用来表示该段是否在内存中.显然这里有一解决办法就是当新运行的进程空间不够时,将老进程不常用的段患处到硬盘,腾出空间给新进程用,等到老进程再次需要该段的时候,再将该段载入内存
  - **内存段是如何被换出的?**在保护模式下,段描述符是段的身份证.当cpu在引用一个段的时候,都要先查看段描述符.如果该段描述符中P位为1,表示该段在内存中存在,访问过该段后,CPU会将段描述符中的A位置1,表示近来刚访问过该段.相反如果P位为0,说明内存中并不存在该段,这时候CPU会抛出NP(段不存在)异常,转而去执行中断描述符表中NP异常对应的中断处理程序,此中断处理程序是操作系统负责提供的,该程序的工作是将相应的段从外存(比如硬盘)中载入内存，并将段描述符的P位置1，中断处理函数结束后返回，CPU重复执行这个检查，继续查看该段描述符的P位，检查通过，将A位置1.
  - **内存段时何时被移出到外存的？**段描述符的A位由CPU置1，但清0工作可是由操作系统完成的，操作系统每次发现该位为1，就将该位清0，在一个周期内统计该位为1的次数就知道该段的使用频率了，从而可以找出使用频率最低的段，当物理内存不足时，可以将使用频率最低的段换出到硬盘。当段被换出到硬盘，操作系统将该段描述符的P位置0.

- 但是对于这种方法，如果物理内存特别小，无法容纳一个段的或者进程的段特别大，换入换出特别慢，就不好使了。问题的本质在于目前CPU只认物理地址，而且必须时连续的一整个段的地址，如果我们可以解除产生的线性地址和最终的物理地址的一一对应关系，将其对应关系重新映射就解决了这个问题

### 一级页表

#### 分页机制

- **核心思想**：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续
- **个人理解1**：首先分页机制是建立在分段机制上的，也就是说产生线性地址之前的步骤不变，依然是CPU想要访问哪个地址，就通过“段基址+段偏移”给出地址，但是与之前不同的是，之前给出的线性地址，这里会直接送上地址总线，也就是当成物理地址直接访问。而开启分页机制后，线性地址会再经过一个“查页表”之类的过程将线性地址转换为其他物理地址，这项查找工作是由页部件自动完成的。由于有了线性地址到真实物理地址的这层映射，经过段部件输出的线性地址便有了一个名字：虚拟地址
- **作用**：1.分页可以将线性地址转换成物理地址，而这个映射关系是操作系统定义的 2. 用大小相等的页代替大小不等的段
- **个人理解2**：在没有开启分页模式之前，换入换出的单位是进程的某个段，现在可以更加细化，将大小不一的数据段代码段拆成粒度更细的页

#### 页表

- 虚拟地址和物理地址的映射关系是需要地方去存储的，这个存储的地方就是页表
- **页表**就是一个N行1列的表格，页表中的每一行(只有一个单元格)称为**页表项**(Page Table Entry,PTE)，其大小是4字节，页表项的作用是存储页的物理地址。当访问一个线性地址时，实际就是在访问页表项所记录的物理内存地址。

#### 地址转换原理

- 32位地址表示4GB的空间，前面提到现在将段的划分粒度缩小到一个页，往大了说其实就是将整个4GB的空间划分为好多个页，页大小*页个数 = 4GB。如果页的大小为1字节，那么划分空间的方法就是和之前一样，想要涵盖整个空间，那就需要4G个页。所以页的大小需要合理选择，官方采用**页的大小是4KB**，总共需要**1M个**页，就可以涵盖4GB的空间。
- 4GB的任意一个地址最终会落到这1M个页的某个页内，首先要知道这个地址属于哪个页，然后再给出它在页中的偏移就可以找到了这个地址，因为有1M个页，以某个地址的高20为索引在页表中定位这个地址所在的页表项，然后以后12位为偏移量就可以在页中找到这个地址了。
- **地址转换原理**：用线性地址的高20位作为页表项的索引，每个页表项要占4字节大小，所以这高20位的索引乘以4后才是该页表项相对于**页表物理地址**的**字节偏移量**。用**cr3寄存器中的页表物理地址**加上该偏移量便是该**页表项的物理地址**，从该页表项中得到映射的**物理页地址**，然后用虚拟地址的低12位与该物理页地址相加，所得的地址之和便是最终要访问的**物理地址**。
- **注意**：有的人会以为页表项中存放的是物理地址，而不是虚拟地址，否则的话就找不到了存放想找的物理页地址的那个地方了

#### 页部件

- CPU中集成了专门用来干这固定转换算法工作的硬件模块，我们把该部件称为页部件。程序给出一个线性地址，页部件分析线性地址，按照以上算法，自动在页表中检索到物理地址

### 二级页表

#### 采用二级页表的原因

1. 一级页表中最多容纳1M个页表项，每个页表项是4字节，如果页表项全满的话，便是4MB大小
2. 一级页表项中所有的页表项必须提前建好，原因是操作系统要占用4GB虚拟地址空间的高1GB，用户进程要占用低3GB
3. 每个进程都有自己的页表，进程一多，光是页表占用的空间就很可观了。

- 归根到底，不要一次性地将全部页表项全部建好，需要时动态创建页表项

#### 二级页表

- 一级页表时将这1M这个标准页对应的起始地址放到一张页表中，二级页表是将这1M个标准页的起始地址平均放置到1K个页表中。每个页表中包含有1K个页表项，页表项是4字节大小，页表包含1K个页表项，故页表大小为4KB，恰好是一个标准页的大小。拆分出1K个页表，自然也需要地方去记录他们，每个页表的物理地址在页目录表中以页目录项(Page Directory Entry,PDE)的形式存储
- 这里的核心就是：页表项中分配的物理页地址在真正的物理内存中离散分布，毫无规律可言，操作系统负责这些物理页的分配和释放。由于页目录表和页表本身都要占用内存，且为4KB大小，故它们也会由操作系统在物理内存中分配一物理页存放

#### 二级页表地址转换原理

1. 用虚拟地址的高10位乘以4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址
2. 用虚拟地址的中间10位乘以4，作为页表内的偏移地址，加上在第1步中得到的页表物理地址，所得的和，便是页表项的物理地址，读取该页表项，从中获取到分配的物理页地址
3. 虚拟地址的高10位和中间10位分别是PDT和PTE的索引值，所以它们需要乘以4.但低12位就不是索引值，所以直接加上第二步中得到的物理页地址，所得的和就是最终转换的物理地址
4. 转换例程示意，见drawio文件         

### 启用分页机制

#### 一、准备好页表

- 页目录项、页表项结构见drawio文件，需要说明的是因为页目录项和页表项中的都死物理页地址，标准页大小是4KB,故地址都是4K的倍数，也就是地址的低12位是0,所以只需要记录物理地址高20位就可以了，这样省出来的12位可以从来添加其他属性
- 进程可以有无限多个，而操作系统只有一个，所以操作系统必须“共享”给所有用户进程。具体方法是：只要保证所有用户进程虚拟地址空间3GB~4GB对应的页表项中记录的物理页地址是相同的就行

#### 二、将页表地址写入控制寄存器cr3

- 控制寄存器cr3用于存储页表物理地址，所以cr3寄存器又称为页目录基址寄存器。

