# 5_保护模式进阶,向内核迈进

## 获取物理内存

### Linux获取物理内存的方法

- 首先要明确的是获取内存是在进入保护模式之前就要获取到,之后开启分页的内存管理都是建立在物理内存之上的
- 在Linux2.6内核中,是用detect_memory函数来获取内存容量的.其本质上就是通过调用BIOS中断0x15实现的,分别是BIOS中断0x15的三个子功能
- 如果三个方式都失败了,由于无法获取内存信息,后续程序无法加载,只好将机器挂起,停止运行.

## 启用分页机制

### 内存为什么要分页

首先我们来分析一个问题,进入保护模式后,当不开启分页时,多个进程想要同时运行,但是实际的物理内存容量不够怎么办?

- 在前面学习中,有提到过段描述符中有一个P位,用来表示该段是否在内存中.显然这里有一解决办法就是当新运行的进程空间不够时,将老进程不常用的段患处到硬盘,腾出空间给新进程用,等到老进程再次需要该段的时候,再将该段载入内存
  - **内存段是如何被换出的?**在保护模式下,段描述符是段的身份证.当cpu在引用一个段的时候,都要先查看段描述符.如果该段描述符中P位为1,表示该段在内存中存在,访问过该段后,CPU会将段描述符中的A位置1,表示近来刚访问过该段.相反如果P位为0,说明内存中并不存在该段,这时候CPU会抛出NP(段不存在)异常,转而去执行中断描述符表中NP异常对应的中断处理程序,此中断处理程序是操作系统负责提供的,该程序的工作是将相应的段从外存(比如硬盘)中载入内存，并将段描述符的P位置1，中断处理函数结束后返回，CPU重复执行这个检查，继续查看该段描述符的P位，检查通过，将A位置1.
  - **内存段时何时被移出到外存的？**段描述符的A位由CPU置1，但清0工作可是由操作系统完成的，操作系统每次发现该位为1，就将该位清0，在一个周期内统计该位为1的次数就知道该段的使用频率了，从而可以找出使用频率最低的段，当物理内存不足时，可以将使用频率最低的段换出到硬盘。当段被换出到硬盘，操作系统将该段描述符的P位置0.

- 但是对于这种方法，如果物理内存特别小，无法容纳一个段的或者进程的段特别大，换入换出特别慢，就不好使了。问题的本质在于目前CPU只认物理地址，而且必须时连续的一整个段的地址，如果我们可以解除产生的线性地址和最终的物理地址的一一对应关系，将其对应关系重新映射就解决了这个问题

### 一级页表

#### 分页机制

- **核心思想**：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续
- **个人理解1**：首先分页机制是建立在分段机制上的，也就是说产生线性地址之前的步骤不变，依然是CPU想要访问哪个地址，就通过“段基址+段偏移”给出地址，但是与之前不同的是，之前给出的线性地址，这里会直接送上地址总线，也就是当成物理地址直接访问。而开启分页机制后，线性地址会再经过一个“查页表”之类的过程将线性地址转换为其他物理地址，这项查找工作是由页部件自动完成的。由于有了线性地址到真实物理地址的这层映射，经过段部件输出的线性地址便有了一个名字：虚拟地址
- **作用**：1.分页可以将线性地址转换成物理地址，而这个映射关系是操作系统定义的 2. 用大小相等的页代替大小不等的段
- **个人理解2**：在没有开启分页模式之前，换入换出的单位是进程的某个段，现在可以更加细化，将大小不一的数据段代码段拆成粒度更细的页

#### 页表

- 虚拟地址和物理地址的映射关系是需要地方去存储的，这个存储的地方就是页表
- **页表**就是一个N行1列的表格，页表中的每一行(只有一个单元格)称为**页表项**(Page Table Entry,PTE)，其大小是4字节，页表项的作用是存储页的物理地址。当访问一个线性地址时，实际就是在访问页表项所记录的物理内存地址。

#### 地址转换原理

- 32位地址表示4GB的空间，前面提到现在将段的划分粒度缩小到一个页，往大了说其实就是将整个4GB的空间划分为好多个页，页大小*页个数 = 4GB。如果页的大小为1字节，那么划分空间的方法就是和之前一样，想要涵盖整个空间，那就需要4G个页。所以页的大小需要合理选择，官方采用**页的大小是4KB**，总共需要**1M个**页，就可以涵盖4GB的空间。
- 4GB的任意一个地址最终会落到这1M个页的某个页内，首先要知道这个地址属于哪个页，然后再给出它在页中的偏移就可以找到了这个地址，因为有1M个页，以某个地址的高20为索引在页表中定位这个地址所在的页表项，然后以后12位为偏移量就可以在页中找到这个地址了。
- **地址转换原理**：用线性地址的高20位作为页表项的索引，每个页表项要占4字节大小，所以这高20位的索引乘以4后才是该页表项相对于**页表物理地址**的**字节偏移量**。用**cr3寄存器中的页表物理地址**加上该偏移量便是该**页表项的物理地址**，从该页表项中得到映射的**物理页地址**，然后用虚拟地址的低12位与该物理页地址相加，所得的地址之和便是最终要访问的**物理地址**。
- **注意**：有的人会以为页表项中存放的是物理地址，而不是虚拟地址，否则的话就找不到了存放想找的物理页地址的那个地方了

#### 页部件

- CPU中集成了专门用来干这固定转换算法工作的硬件模块，我们把该部件称为页部件。程序给出一个线性地址，页部件分析线性地址，按照以上算法，自动在页表中检索到物理地址

### 二级页表

#### 采用二级页表的原因

1. 一级页表中最多容纳1M个页表项，每个页表项是4字节，如果页表项全满的话，便是4MB大小
2. 一级页表项中所有的页表项必须提前建好，原因是操作系统要占用4GB虚拟地址空间的高1GB，用户进程要占用低3GB
3. 每个进程都有自己的页表，进程一多，光是页表占用的空间就很可观了。

- 归根到底，不要一次性地将全部页表项全部建好，需要时动态创建页表项

#### 二级页表

- 一级页表时将这1M这个标准页对应的起始地址放到一张页表中，二级页表是将这1M个标准页的起始地址平均放置到1K个页表中。每个页表中包含有1K个页表项，页表项是4字节大小，页表包含1K个页表项，故页表大小为4KB，恰好是一个标准页的大小。拆分出1K个页表，自然也需要地方去记录他们，每个页表的物理地址在页目录表中以页目录项(Page Directory Entry,PDE)的形式存储
- 这里的核心就是：页表项中分配的物理页地址在真正的物理内存中离散分布，毫无规律可言，操作系统负责这些物理页的分配和释放。由于页目录表和页表本身都要占用内存，且为4KB大小，故它们也会由操作系统在物理内存中分配一物理页存放

#### 二级页表地址转换原理

1. 用虚拟地址的高10位乘以4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址
2. 用虚拟地址的中间10位乘以4，作为页表内的偏移地址，加上在第1步中得到的页表物理地址，所得的和，便是页表项的物理地址，读取该页表项，从中获取到分配的物理页地址
3. 虚拟地址的高10位和中间10位分别是PDT和PTE的索引值，所以它们需要乘以4.但低12位就不是索引值，所以直接加上第二步中得到的物理页地址，所得的和就是最终转换的物理地址
4. 转换例程示意，见drawio文件         

### 启用分页机制三步走

#### 一、准备好页表

- 页目录项、页表项结构见drawio文件，需要说明的是因为页目录项和页表项中的都死物理页地址，标准页大小是4KB,故地址都是4K的倍数，也就是地址的低12位是0,所以只需要记录物理地址高20位就可以了，这样省出来的12位可以从来添加其他属性
- 进程可以有无限多个，而操作系统只有一个，所以操作系统必须“共享”给所有用户进程。具体方法是：只要保证所有用户进程虚拟地址空间3GB~4GB对应的页表项中记录的物理页地址是相同的就行

#### 二、将页表地址写入控制寄存器cr3

- 控制寄存器cr3用于存储页表物理地址，所以cr3寄存器又称为页目录基址寄存器。

#### 三、将寄存器cr0的PG位置１

### 启用分页后

- 虚拟地址到物理地址的映射关系见配套代码
- 虚拟内存图见drawio文件
- 用虚拟地址获取页表中各数据类型的方法
  - 获取页目录表物理地址:让虚拟地址的高20位为0xfffff，低12位为0x000，即0xfffff000，这也是页目录表中第0个页目录项自身的物理地址
  - 访问页目录中的页目录项，即获得页表物理地址：要使虚拟地址为0xfffffxxx，其中xxx是页目录项的索引乘以4的积。
  - 访问页表中的页表项：要使虚拟地址高10位为0x3ff，目的是获取页目录表物理地址。中间10位为页表的索引，因为是10位的索引值，所以这里不用乘以4.低12位为页表内的偏移地址，用来定位页表项，它必须是已经乘以4后的值。

### 快表

- 同样是因为虚拟地址到物理地址的映射算法比较费事，而且页表是存储在内存中的，频繁访问内存会降低运行速度，所以处理器准备了一个高速缓存，可以匹配高速的处理器速率和低速的内存访问速度，专门用来存放虚拟地址页框与物理地址页框的映射关系，这个调整缓存就是TLB，即Translation Lookside Buffer,俗称**快表**
- 有了TLB，处理器在寻址之前会用虚拟地址的高20位作为索引来查找TLB中的相关条目，如果匹配到了相关条目则返回虚拟地址所映射的物理页框地址，否则会查询内存中的页表，获得页框物理地址后再更新TLB
- TLB中的数据只是当前任务的部分页表，而且只有P位为1的页表才有资格在TLB中，如果TLB被装满了，需要将很少使用的条目换出，所以TLB必须实时更新，而TLB的维护工作交给了操作系统开发人员，更新TLB有以下两种方法：
  - 重新加载CR3,会使整个TLB失效
  - 指令invlpg，它用在TLB中刷新某个虚拟地址对应的条目，指令操作数是虚拟地址

## 加载内核

### 编译工具链

- GCC参数　-c :编译、汇编到目标代码，不进行链接，直接生成目标文件　-o :将输出的文件以指定文件名来存储，有同名文件直接覆盖
- ld参数　-Ttext:指定起始虚拟地址　-e 指定数字或符号入口　

### elf(更多信息可以参见《程序员的自我修养－链接、装载与库》)

- ELF－Executable and Linkable Format,可执行链接格式，是一种**格式**，包括我们常见的二进制可执行文件，Linux下.o结尾的目标文件和.so结尾的动态库文件(以上说的都是在Linux下，在Window下的可执行文件格式是PE即Portable Executable)
- ELF文件格式分为文件头和文件体两部分，文件头稍微复杂一点，先用个ELF header从“全局上”给出程序文件的组织结构概要出程序中其他头表的位置大小等信息，然后各个段和节的位置、大小等信息再分别从“具体的”程序头表和节头表中予以说明。

## 特权级

### 特权级环状结构

- 操作系统位于最内环的0级特权，它要直接控制硬件，掌握各种核心数据
- 系统程序分别位于1级特权和2级特权，运行在这两层的程序一般是虚拟机、驱动程序等系统服务
- 最外层的是3级特权级，我们的用户程序就运行在此层

### TSS

- TSS，即Task State Segment，意为任务状态段，它是处理器在硬件上原生支持多任务的一种实现方式
- TSS，是每个任务都有的结构，它用于一个任务的标识，相当于任务的身份证
- 任务特权级变换时，本质上是处理器的当前特权级在变换，处理器在不同特权级下，应该用不同特权级的栈。当处理器进入不同特权级时，它自动在TSS中找同特权级的栈指针，TSS的地址在寄存器TR(Task Register)中
- 特权级转移分两类：
  - 由中断门、调用门等手段实现低特权级转向高特权级
  - 由调用返回指令从高特权级返回到低特权级，这是**唯一**能让处理器降低特权级的情况

- 由上面的点进行引申：除了调用返回外，处理器**只能**从低特权级向高特权级转移。每次转到高特权级时，处理器自动从TSS中找到对应的高特权级栈地址，而在高特权级返回低特权级时，处理器不需要在TSS中去寻找低特权级目标栈的，因为在转到高特权级时，处理器会自动把当时低特权级的栈地址(SS和ESP)压入转移后的高特权级栈，返回时只要从高特权级栈中拿就好了。而下次处理器再进入高特权级时，依然会在TSS中寻找高特权级栈

### CPL、DPL、RPL

- CPL(Current Privilege level)当前进程的权限级别，在CPU中运行的是指令，其运行过程中的指令，总会属于某个代码段，该**代码段**的特权级，存在于cs寄存器的低两位,即**CS.RPL = CPL**
  - 即当前正在运行的代码所在代码段的段描述符中的DPL = CPL = CS.RPL
  - 对于任何程序的执行而言，至少要将代码段寄存器CS,数据段寄存器DS和堆栈段寄存器SS赋予有效的段选择子，也就是说在同一时刻程序中可以有多个段选择子，也就是可以有多个RPL,然而只有CS寄存器中的RPL才等于CPL
- DPL存储在段描述符中，规定访问该段的权限级别(Descriptor Privilege level),每个段的DPL固定
- RPL(Request Privilege level)，存在与段选择子的bit 0 和 bit 1两位中，每个段选择子都有自己的RPL,它说明的是进程对段访问的请求权限，是由操作系统提供的。
  - RPL对于每个段来说不固定，两次访问一个段时的RPL可以不同

### 特权级检查

#### 一致性代码

- **代码段只能平级访问**

- 因为代码段只能平级访问，所以为了让其他特权级代码段运行的机会，就采用一致性代码，也称依从代码段，用来实现低特权级代码向高特权级的代码转移，即**如果自身是转移后的目标段**，自己的特权级(DPL)一定要高于转移前的CPL.而访问一致性代码段的一大特点就是转以后的特权级不以此一致性代码段的DPL为主，而是与转移前的低特权级一致。

#### 一、对数据段和堆栈段访问时的特权级控制

- 核心准则就是：**只有相同或者更高级的代码才能访问相应的数据段**，检查如下：要求访问数据段或堆栈段的CPL≤待访问的数据段和堆栈段的DPL,同时选择子的RPL≤待访问的数据段和堆栈段的DPL

#### 二、对代码段访问的特权级控制

**一些“定律”**：

- **所有的程序跳转，CPU都不会把段选择子的RPL赋给跳转后的程序的CS.RPL**
- 总结归纳起来，跳转后程序的CPL(CS.RPL)只会有下面两种可能：
  - **跳转后的程序的CPL(CS.RPL) = 跳转前的CPL(CS.RPL)**
  - **跳转后的程序的CPL(CS,RPL) = 跳转后程序的段描述符的DPL**

跳转分两大类：

1. **普通跳转(没有经过门这东西)**：即jmp或call后跟着48位全指针(16位段选择子＋32位地址偏移)，且其中的段选择子指向代码段描述符。普通跳转不能使特权级发生跃迁，即不会引起CPL的变化。
   - 特权级检查条件：目标是非一致性代码：访问者的CPL等级等于被访问者的DPL.目标是一致性代码：访问者的CPL等级权力小于被访问者的DPL，其他RPL是不检查的

2. **通过调用门的跳转**：当段间转移指令jmp和段间转移指令call后跟着目标段选择子指向一个调用门描述符时，就是利用调用门跳转。所谓**门结构就是记录一段程序起始地址的描述符**，这时如果选择子后跟着32位的地址偏移，如"call 0x0008:0x1234",偏移量会被cpu忽略，因为门描述符里已经记录了目标代码的偏移
   - 与普通跳转的不同：比普通跳转多一步，即在访问调用门描述符时要将门描述符DPL当做一个**数据段DPL**来访问检查(见第一大类，对数据段和堆栈段访问时的特权级控制)，只有满足了检查条件，CPU才会进一步从调用门描述符中读取目标代码段的选择子和地址偏移，进行下一步
   - 从调用门描述符中读取目标代码的选择子和地址偏移后，情况又和普通跳转一样了。而有所不同的是**CPU会将读到的目标代码段选择子中的RPL清0**。之后，CPU会开始对当前程序的CPL,目标代码段选择子的RPL(被清0)和由目标代码选择子指示的目标代码段描述符中的DPL进行特权级检查。
     - 目标是一致性代码：高特权级的一致性代码是用低等级用来访问，所以要求CPL(CS:RPL)≥目标代码段DPL,而RPL不检查
     - 目标是非一致性代码：
       - JMP指令是用来平级跳转的：要求CPL=DPL，RPL≤CPL,跳转后不会改变CPL
       - CALL指令可以用来向高特权级转移:要求CPL≥目标代码DPL,跳转后DPL的值赋给CPL,这是我们目前唯一见到的使程序当前优先级发生变化的跳转－－即用CALL指令＋调用门方式跳转，且目标代码是非一致代码段

#### 注意要点：

1. 我们要进行特权级判断的时候是拿目标代码段的DPL与CPL和RPL(这里的RPL不一定是CS.RPL,同一时刻，程序中可以有多个段选择子)
2. 防止用户进程搞破坏的核心就是：**如果用户进程提供伪造的选择子，提升了rpl,但是操作系统会将其rpl替换为该进程的CPL。**

#### 综合实例

假设当前处理器正在 DPL 为 3 的代码段上运行，即正在运行用户程序，故处理器当前特权级 CPL 为 3。此时用户进程想获取安装的物理内存大小，该数据存储在操作系统的数据段中，该段 DPL 为 0。由于当前运行的是用户程序，CPL 为 3，所以无法访问 DPL 为 0 的数据段。于是它使用调用门向系统救助。调用门是操作系统安装在全局描述符表 GDT 中的，为了让用户进程可以使用此调用门，操作系统将该调用门描述符的 DPL 设为 3。该调用门只需要一个参数，就是用户程序用于存储系统内存容量的缓冲区所在数据段的选择子和偏移地址。调用门描述符中记录的就是内核服务程序所在代码段的选择子及在代码段内的偏移量。用户进程用“call 调用门选择子”的方式使用调用门，此调用门选择子是由操作系统提供的，该选择子的 RPL 为 3，此时如果用户伪造一个调用门选择子也没用，因为此选择子是用来索引门描述符的，并不用来指向缓冲区的选择子，调用门选择子中的高 13 位索引值必须要指向门描述符在 GDT 中的位置，选择子中低 2 位的 RPL 伪造也没意义，因为此时 CPL 为 3，是短板，以它为主。此时处理器便进行特权级检查，CPL 为 3，RPL 为 3，门描述符 DPL 为 3，即数值上（CPL≤DPL && RPL≤DPL）成立，初步检查通过。接下来还要再将 CPL 与门描述符中选择子所对应的代码段描述符 DPL 比较，这是调用门对应的内核服务程序的 DPL，为叙述方便将其记作 DPL_CODE。由于 DPL_CODE 是内核程序的特权级，所以DPL_CODE 为 0，CPL 为 3，即数值上满足 CPL≥DPL_CODE，CPL 比目标特权级低，检查通过，该用户程序可以用调用门，于是处理器的当前特权级 CPL 的值用 DPL_CODE 代替，记录在 CS.RPL 中，此时CPL 变为 0。接下来，处理器便以 0 特权级的身份开始执行该内核服务程序，由于该服务程序的参数是用户提交的缓冲区所在的数据段的选择子及偏移量，为避免用户将缓冲区指向了内核的数据区，安全起见，在该内核服务程序中，操作系统将这个用户所提交的选择子的 RPL 变更为用户进程的 CPL，也就是指向缓冲区所在段的选择子的 RPL 变成了 3。前面说过，参数都是内核在 0 级栈中获得的，虽然用户进程将缓冲区的选择子及偏移量压在了 3 特权级栈中，但由于调用门的特权级变换，参数已经由处理器在固件一级上自动复制到 0 特权级栈中了。用户的代码段寄存器 CS 也在特权级发生变化时，由处理器自动压入到 0 特权级栈中，所以操作系统需要的参数都可以在自己的 0 特权级栈中找到。用户缓冲区的选择子修改过后，接下来内核服务程序将用户所需要的内存容量大小写到这个选择子和用户提交的偏移量对应的缓冲区。如果用户程序想搞破坏，所提交的这个缓冲区选择子指向的目标段不是用户进程自己的数据段，而是内核数据段或内核代码段，由于目标段的 DPL 为 0，虽然此时已在内核中执行，CPL 为 0，但选择子 RPL 已经被改为 3，数值上不满足 CPL≤DPL && RPL≤DPL，往缓冲区中的写入被拒绝，处理器引发异常。如果用户程序提交的缓冲区选择子确实指向用户程序自己的数据段，DPL 则为 3，数值上满足 CPL≤DPL && RPL≤DPL，往缓冲区中的写入则会成功。如果中断服务程序内部再有访问内核自己内存段的操作，还会按照数值上（CPL≤DPL && RPL≤DPL）的策略进行新一轮的特权检测。通常，如果不是用户程序向内核提交缓冲区地址来接收数据的话，内核不会主动访问用户的内存段，多是访问自己的数据段或代码段，内核服务程序中若访问内核自己的内存段，由于内存段的 DPL 为 0，所以段选择子的 RPL 也必须为 0

### IO特权级

#### 分级的原因

在保护模式下，处理器的阶级不仅体现在数据和代码的访问，还体现在指令上，指令分级原因：

- 一方面是因为有些指令的执行对计算机有这严重的影响，它们只有在0特权级下被执行，因此被称为特权指令，比如hlt指令、lgdt等对计算机的运行起着非同小可的影响，必须由操作系统亲自执行
- 对I/O读写的控制的特权是由标志寄存器eflags中的IOPL位和TSS中的IO位图决定的，它们用来指定执行IO操作的最小特权级。IO相关的指令只有在当前特权级小于IOPL时才能执行，所以它们称为IO敏感指令

#### eflags寄存器的IOPL

- IOPL位是eflags的12~13位，除了限制当前任务进行IO敏感指令的最低特权级外，还用来决定任务是否允许操作全部的IO端口
- 可以改变IOPL的指令只有popf和iretd指令，依然是只有在0特权级下才能执行

#### IO位图

- 当数值上CPL>IOPL,即开关被关上，IO端口不能被操作，则可以通过IO位图来设置部分端口的访问权限，也就是在先在整体上关闭，再在局部打开
- 这么做是为了提速，如果所有的IO端口访问都要经过内核的话，由低特权级转向高特权级时是需要保存任务上下文的，这个过程也是要消耗处理器时间的
- 位图中的每一位代表相应的端口，比如第0个bit表示第0个端口。如果相应位被置为0，表示相应端口可以访问
- IO位图位于TSS的顶端，TSS结构中有一项“IO位图在TSS中的偏移地址”
