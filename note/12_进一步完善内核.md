# 12_进一步完善内核

## Linux系统调用浅析

### 系统调用

- 系统调用就是让用户进程申请操作系统的帮助，让操作系统帮其完成某项工作，也就是相当于用户进程调用了操作系统的功能，因此系统调用准确来说应该被称为“操作系统功能调用”

### Linux

- Linux系统调用是用中断门来实现的，通过软中断指令int来主动发起中断信号。
- 由于要支持的系统功能很多，不能一个系统调用就占用一个中断向量，所以Linux只占用一个中断向量号，即0x80，处理器执行指令int 0x80便触发了系统调用。而在系统调用之前要在寄存器eax中写入子功能号。
- 我们通常在Linux中使用的调用是经过C运行库glibc(GNU发布的libc库版本)提供的，实际上是库函数。这样做的原因之一就是为了实现跨平台兼容。因为库函数几乎都是对宿主系统的系统调用接口的封装
- 系统调用里有用到一个(_NR_##name)的，这里的“##”表示联结字符串

## 系统调用的实现

### 框架

- 一个系统功能调用分为两部分，一部分是暴露给用户进程的接口函数，它属于用户空间，此部分只是用户进程使用系统调用的途径，只负责发需求。另一部分是与之对应的内核具体实现，它属于内核空间，此部分完成的是功能需求。

## 让用户进程说话

### 可变参数的原理

- 程序本身占用的内存称为静态内存，而程序在运行期间若需要新的内存空间，称为动态内存
- 函数占用的也是静态内存，因此也得提前告诉编译器自己占用的内存大小。为了在编译时获取函数调用时所需要的内存空间（这通常是在栈中分配内存单元），编译器要求提供函数声明，声明中描述了函数参数的个数和类型，编译器用它们来计算参数所占据的栈空间。因此编译器不关心函数声明中参数的名称，它只关心参数个数及类型，
- 编译器允许函数的参数个数不固定，得益于编译器采用C调用约定来处理函数的传参方式。C调用约定规定：由调用者把参数以从右向左的顺序压入栈中，并且由调用者清理栈中的参数。根据C调用约定，调用者都能完好回收栈空间，不必担心栈溢出等问题。
- 因此看似“动态”的可变参数函数，其实也是“静态”固定的
- 格式化字符串，如printf("hello %s!","martin")，其中的"hello %s"便是format。在格式化字符串中的字符'%'便是在栈中寻找可变参数的依据，紧跟在'%'后面的是类型字符，类型字符表示数据类型和进制相关的内容。格式化字符串中有多少'%'，就在栈中找多少次参数

### printf

- printf里面包含"%类型字符"，"%c"，表示输出单个字符；"%d"用于输出十进制整形，"%x"表示输出十六进制

## 完善堆内存管理

### malloc底层原理

- 虽然之前已经实现了内存管理，但是显得过于粗糙，分配的内存都是以4KB大小的页框为单位的，当我们仅需要几十字节、几百字节这样的小内存块时，显然无法满足这样的需求了，为此必须实现一种小内存块的管理
- arena是很多开源项目中都会用到的内存管理概念，将一大块内存划分成多个小内存块，每个小内存块之间互不干涉、可以分别管理，这样众多的小内存块就被称为arena
- 根据请求的内存量的大小，操作系统会根据请求的内存量的大小，选择不同规格arena的内存块，因此为了支持多种容量内存块的分配，我们要提前建立好多种不同容量内存块的arena
- 内存块的数量等于arena内存池区域的大小/内存块规格容量
- arena是个提供内存分配的数据结构，它分为两部分，一部分是元信息，用来描述自己内存池中空闲内存块的数量，通过它可以间接获知本arena锁包含内存块的规格大小；另一部分就是内存池区域，这里面有无数的内存块，此部分占用arena大量的空间
- 起始为某一类型内存块供货的arena只有1个，当此arena中的全部内存块都被分配完时，系统再创建一个同规格的arena继续提供该规格的内存块，arena规模逐渐增大，逐步形成arena集群。
- 为了跟踪每个arena中的空闲内存块，分别为每一种规格的内存块建立一个内存块描述符，在其中记录内存块规格大小，以及位于所有同类arena中空闲内存块链表。内存块描述符将所有同类arena中空闲内存块汇总，相当于一个超级大的仓库，分配小内存块时必须经过此入口。内存块规格有多少种，内存块描述符就有多少种
- 总结：在内存管理系统中，arena为任意大小内存块的分配提供了统一的接口，它既支持1024字节以下的小块内存的分配，又支持大于1024字节以上的大块内存。arena是个内存仓库，并不直接对外提供内存分配，只有内存块描述符才对外提供内存块，内存块描述符将同类arena中的空闲内存块汇聚到一起，作为某一规格内存块的分配入口。因此，内存块描述符与arena是一对多的关系，每个arena都要与唯一的内存块描述符关联起来，多个同规格的arena为同一规格的内存块描述符供应内存块，它们各自的元信息中用内存块描述符指针指向同一个内存块描述符

### 底层实现

- 一直说arena用来提供内存块，是如何实现的呢？其实就是当申请一个内存块时，我们会从堆中申请一个页框，用来创建arena内存仓库，开头放元信息，剩下的就是名副其实用来分配的内存块实体了

- 为了实现用户进程的堆内存管理，需要在其PCB中添加一项:内存块描述符数组。目前我们支持7种规格的内存块，也就是说这个数组有7个成员。每个内存块描述符可以指明内存块的大小，每个arena中可容纳的块的数量，和现在可用的所有内存块的数量组成的列表

- 对于大内存的处理称之为释放，就是把页框在虚拟内存池和物理内存池的位图中将相应位置0，对于小内存的处理称之为回收，是将arena中的内存块重新放回到内存块描述符中的空闲块链表

  