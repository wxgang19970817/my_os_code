# 6_完善内核

## 函数调用约定

### 什么叫调用约定

- 调用函数时的一套约定，体现在约定函数的传递方式：是放在寄存器？栈？还是两种混合；参数的传递顺序：从左至右还是从右至左；是调用者保存寄存器环境，还是被调用者保存？保存哪些寄存器

**C语言调用约定**

- c语言调用约定准守的是cdecl(C declaration,即C 声明)，约定如下：参数是在栈中传递；EAX、ECX、EDX寄存器是由调用者保存的，其余寄存器由被调用者保存；函数的返回值存储在EAX寄存器中；由调用者清理栈空间；最大的亮点是允许函数的参数不固定

## 汇编和C混合编程

### c库函数和系统调用

- 调用“系统调用”的两种方式
  1. 将系统调用指令封装为C库函数，通过库函数进行系统调用，操作简单
  2. 不依赖任何库函数，直接通过汇编指令int 0x80 （子功能号在eax中）与操作系统通信

- 系统调用输入参数的传递方式：当输入参数小于等于5个时，Linux用寄存器传递函数.当参数个数大于5个时，把参数按照顺序放入连续的内存区域，并将该区域的首地址放到ebx寄存器（要注意与函数传参做区分）

#### 汇编语言和C语言共同协作

- **函数声明的作用**
  - 一方面告诉编译器该函数的参数所需要的栈空间及返回值，方便编译器为其准备好执行环境
  - 另一方面如果该函数是外部文件定义的，一定要在链接阶段将其对应的目标文件一起链接进来

- 在汇编代码中导出符号供外部引用是关键字global，引用外部文件的符号用的是关键子extern
- 在c代码中只要将符号定义为全局便可以被外部引用，一般情况下无须额外关键字修饰，引用外部符号时用extern

## 内联汇编

### 什么叫内联汇编

- 内联汇编称为inline assembly，GCC支持C代码中直接嵌入汇编代码
- 内联汇编按格式分为两大类，一类是最简单的基本内联汇编，另一类是复杂一些的扩展内联汇编，而且其语法是AT&T(GCC只支持它)

### 汇编语法AT&T

- 在Intel中，立即数就是普通的数字，如果让立即数成为内存地址，需要将它用中括号括起来；而AT&T认为，内存地址既然是数字，那数字也应该被当做内存地址，所以数字被优先认为内存地址，想表示单纯的立即数，需要额外在前面加个前缀$

### 基本内联汇编

- 基本内联汇编是最简单的内联形式：

  ```assembly
  asm  [volatile] ("assembly code")
  ```

  - 关键字asm用于声明内联汇编表达式，这是内联汇编固定的部分，不可少。asm和_ _asm_ _是一样的，是由gcc定义的宏：#define asm  _ _asm_ _
  - gcc有个优化选项-o,可以指定优化级别，关键字volatile是可选项，告诉gcc“不要修改我写的汇编代码”
  - "assembly code"是咱们所写的汇编代码，它必须位于圆括号中，而且必须用双引号引起来，可以为空

- assembly code的规则
  - 指令必须用双引号引起来，无论双引号中是一条指令或多条指令
  - 一对双引号不能跨行
  - 指令之间用分号，换行符或换行符加制表符分割
  - 即使是指令分布在多个双引号中，gcc最终也要把它们合并到一起来处理，合并之后指令之间必须有分隔符
  - 在基本内联汇编中，若要引用C变量，只能将它定义为全局变量，如果定义为局部变量，链接时会找不到这两个符号

### 扩展内联汇编

- 格式

  ```assembly
  asm [volatile] ("assembly code" : output : input : clobber/modify)
  ```

  - 相比之前多的outpt、input和clobber/modify，每一项都可以省略，连带的冒号也可以省略
  - output:用来指令汇编代码的数据如何输出给c代码使用，操作数格式："操作数修饰符约束名"(C变量名)
  - input:用来指定C中数据如何输入给汇编使用，操作数格式："操作数修饰符约束名"(C变量名)
  - clobber/modify:汇编代码执行后会破坏一些内存或寄存器资源，用过此项通知寄存器，可能造成寄存器或内存数据的破坏

- 例子

```c
#include<stdio.h>
void main(){
	int in_a = 1, sum = 0;
    asm("addl %1,%0;" : "=a"(sum) : "%I"(2),"0"(in_a));
    printf("sum is %d\n ",sum);
}
```

详解：约束a将寄存器eax分配给变量sum,作为输出。在输入中立即数约束I,表示传入立即数2，用到的修饰符"%"表示约束I对应的操作数可以和下一个输入所约束的操作数对换位置，下一个输入是"0"(in_a)，前面用了通用约束"0"，这表示，要求gcc把分配给C变量in_a的操作数(寄存器或内存)同序号0对应的汇编操作数一样，也就是in_a也被分配为eax
