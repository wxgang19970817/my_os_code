# 15_系统交互

## fork的原理和实现

### 什么是fork

- fork函数原型是pid_t fork(void)，返回值是数字，该数字有可能是子进程的pid，有可能是0，也有可能是-1。为了让父进程获知自己的孩子是谁，fork会给父进程返回子进程的pid；fork给子进程返回0，以从返回值上和父进程区分开来。如果fork失败了，返回的数字便是-1，自然也没有子进程产生
- fork之后，由之前的一个进程变成了两个进程，也就是说内存中多了一个进程，进程拥有独立的地址空间，因此两个进程执行的是独立且相同的代码，只是子进程是在fork函数返回之后才开始执行的。

### fork的实现

- 实现fork也要分两步：先复制进程资源，然后再跳过去执行。进程有哪些资源呢？

  1. 进程的pcb，每个任务的“身份证”
  2.  程序体，即代码段数据段等，这是进程的实体
  3. 用户栈，编译器会把局部变量在栈中创建，并且函数调用也离不了栈
  4. 内核栈，进入内核态时，一方面要用它来保存上下文环境，另一方面的作用同用户站一样
  5. 虚拟地址池，每个进程拥有独立的内存空间，其虚拟地址是用虚拟地址池来管理的
  6. 页表，让进程拥有独立的内存空间

  克隆出来的进程将其加到就绪队列就可以参与调度执行了。

### init进程

- 在Linux中，init是用户级进程，它是第一个启动的程序，因此它的pid是1，后续的所有进程都是它的孩子，故init是所有进程的父进程，所以它还负责所有子进程的资源回收
- 所以需要init主动调用fork才能派生出子子孙孙

## read系统调用

- Linux中从键盘获取输入是利用read系统调用

## 实现shell

- shell的功能大致是获取用户的输入，然后分析输入的字符串，判断是内部命令还是外部命令，然后执行不同的策略
- 在Linux中，"Ctrl+u"的作用是清除输入，"Ctrl+l"的作用是清屏
- 路径有绝对路径和相对路径之分。用户为了方便操作，在输入命令或参数时，往往都输入的是相对路径。“当前工作路径”＋“相对路径”＝“绝对路径”。路径输入是发生在用户态，路径转换的工作也是由用户态的程序完成提交给内核态下文件系统函数
- 外部命令是指该命令是个存储在文件系统上的外部程序，执行该命令实际上是从文件系统上加载该程序到内存后运行的过程，也就是说外部命令会以进程的方式执行，如ls就是外部命令
- 内部命令也称内建命令，是系统本身提供的功能，它们并不以单独的程序文件存在，只是一些单独的功能函数，系统执行这些命令实际上是在调用这些函数，如cd、fg、jobs等命令
- C标准库是美国标准协会，即ANSI规定出的一套C函数标准接口，明确规定了每个函数的作用和原型。C标准库与操作系统平台无关
- C运行时库也称为CRT，它是与操作系统息息相关的，它的实现也基于C标准库，因此CRT属于C标准库的扩展。CRT多是补充C标准库中没有的功能，为适配本操作系统环境而定制开发的，因此CRT并不通用，只适用于在本操作系统上运行程序
- CRT都做了什么呢？最主要的就是初始化运行环境，在进入main函数之前为用户进程准备条件，传递参数等，待条件准备好后再调用用户进程的main函数，当用户进程结束时，CRT还要负责回收用户进程的资源。因此可以分析出，main函数一定是被call指令调用的，当用户进程执行完main函数后能够执行固定的代码——系统调用exit或_exit，这样用户进程陷入内核，使处理器的控制权重新回到操作系统手中

## 系统调用wait和exit

### wait和exit的作用

- wait的作用是阻塞父进程自己，直到任意一个子进程结束运行，将返回值传递给父进程，将父进程唤醒。wait通常是由父进程调用的，或者说尽管某个进程没有子进程，但只要它调用了wait系统调用，该进程就被认为是父进程
- exit的作用比较直白，就是使进程“主动退出”

### 孤儿进程和僵尸进程

- 正常情况下的父子进程间通信：

  父进程派生出子进程的目的是让子进程帮忙做一些工作，子进程未必会把工作完成。子进程必须要告诉父进程自己的任务完成了没有，这是通过子进程的返回值体现的，也就是子进程main函数中最后的return语句的值，就是进程所谓的“退出状态”。当子进程执行完main函数后，程序流程会回到C运行库，C运行库会把进程return的返回值通过系统调用exit提交给内核。这是子进程全部执行完的情况，如果进程还没有执行完就调用exit退出的话，必须要提供返回值。其实子进程的返回值并不是手递手直接交给父进程的，进程都是有独立的地址空间，即使是父子进程，它们之间也是相互独立不可互访的，因为这就是与线程的区别，进程间要想互相通信必须要借用内核（无论是管道、消息队列，还是共享内存等进程间通信和形式，无一例外都借助内核）。子进程的返回值提交给内核后，父进程会调用wait，内核就会把子进程的返回值存储到status指向的内存空间。

- 为了方便管理，与进程线管的数据都统一放在pcb中，当进程生命结束时，它的返回值会被内核放在pcb中，进程在调用exit后，内核会把该进程占用的大部分资源回收，比如内存、页表等，但肯定不能将进程的pcb所占的内存回收，因为里面存储着子进程的返回值。父进程调用wait获取子进程的返回值后，再由内核回收子进程pcb所占的1页框内存
- 孤儿进程：当父进程提前退出时，它的所有子进程还在运行，没有一个执行了exit，因为它们的生命周期尚未结束，还在运行。它们就被称为孤儿进程，这时候所有的子进程会被init进程收养，init进程会成为这些进程的新父亲
- 僵尸进程：如果父进程在派生出子进程后并没有调用wait等待接收子进程的返回值，这是某个子进程调用exit退出了，自然没有人来就收返回值了（父进程未退出，因此子进程不能过继给init），因此其pcb所占的空间不能释放，没人为其“收尸”，自然就成了“僵尸进程”。说白了僵尸进程就是针对子进程的返回值是否成功提交给父进程而提出的。由此可以看出僵尸进程是没有进程体的，只剩下一个pcb还在进程队列中

## 管道

### 管道的原理

- 进程虽然是独立的个体，但它们之间有时候需要协作才能完成一项工作。进程间通信方式有很多种，有消息队列、共享内存、socket网络通信等，还有一种就是管道
- 管道是进程间通信的方式之一，在Linux中一切皆文件，因此管道也被视为文件，只是该文件不存在于文件系统上，而是只存在于内存中。管道被多个进程共享，而且存在于内存中，因此共享的原理是所有进程在地址空间都可以访问到它，所以其实管道就是内核空间中的内存缓冲区
- 管道是个环形缓冲区，一端用于从管道中读入数据，另一端用于往管道中国写入数据，这两端使用文件描述符的方式来读取，故进程创建管道实际上是内核为其返回了用于读取管道缓冲区的文件描述符，一个文件描述符用于写，另一个描述符用于读。通常情况下用户进程为内核提供一个长度为2的文件描述符数组，内核会在该数组中写入管道操作的两个描述符
- 通常的用法是进程创建管道之后，马上调用fork，克隆出一个子进程，子进程完全继承了父进程的一切，因此也继承了管道的描述符，这样父子进程就指向同一个管道，实现了父子进程间的通信
- 管道分为两种：匿名管道和命名管道。匿名管道，没有名字，在创建之后只能通过内核为其返回的文件描述符来访问，此管道只对创建它的进程及其子进程可见，对其他进程不可见，因此除了父子进程之外的其他进程便不知道此管道的存在，故匿名管道只能局限于父子进程间的通信。有名管道成功创建后便会在文件系统上存在管道文件，这使得该管道对任何进程都“可见”

### 管道的设计

- Linux除了支持标准的文件系统ext2、ext3、ext4，还支持其他文件系统，如reiserfs、nfs和windows的ntfs。为了向上提供统一的接口，Linux加了一层中间层——VFS，即Virtual File System，虚拟文件系统，向用户屏蔽了各种实现的细节，用户只和VFS打交道。Linux是利用现有的文件结构和VFS索引结点的inode共同完成管道的，并没有单独为管道创建新的数据结构。文件结构中的f_inode指向VFS的inode，该inode指向1个页框大小的内存区域，该区域便是管道用于存储数据的内存空间
- 