# 9_线程

## 实现内核线程

### 执行流

- 任务调度器就是操作系统中用于把任务轮流调度上处理器运行的一个软件模块，是操作系统的一部分。调度器在内核中维护着一个任务表，按照一定的算法，从任务表中选择一个任务，放到处理器上运行，当任务运行的时间片到期后，换另一个任务运行。
- 处理器在所有任务之间来回切换的伪并行的好处是降低了任务的平均响应时间，让那些执行时间短的任务不会因为“后到”而不得不等前面“先来”的且执行时间长的程序执行完后才能获得执行的机会
- 伪并行的弊端在于：在多任务系统中，任务切换是软件完成的，切换工作本身必然要消耗处理器周期，因此所有任务的总共执行时间反而更长了
- 因为处理器只知道加电后按照程序计数器中的地址不断地执行下去，在不断执行的过程中，我们把程序计数器中的下一条指令地址所组成的执行轨迹称为程序的控制执行流
- 执行流对应于代码，大到可以是整个程序文件，即进程，小到可以是一个功能独立的代码块，即函数，而线程本质上就是函数
- 执行流是独立的，它的独立性体现在每个执行流都有自己的栈、一套自己的寄存器映像和内存资源，这是Intel处理器在硬件上规定的，其实就是执行流的上下文环境
- **线程**是运行一段函数的载体：线程是一套机制，可以为一般的代码块创造它所依赖的上下文环境，从而让代码块具有独立性，因此在原理上线程能使一段函数成为调度单元，从而能被专门调度到处理器上执行，单独获得处理器资源。(具有能动性、执行力、独立的代码块)

### 进程和线程的关系、区别简述

- **程序**：是指静态的、存储在文件系统上、尚未运行的指令代码，它是实际运行时程序的映像
- **进程**：是指正在运行的程序，即进行中的程序，程序必须在获得运行所需要的各类资源后才能成为进程，资源包括进程所使用的栈、使用的寄存器等
- 对处理器来说，进程是一种控制流集合，集合中至少包含一条执行流，执行流之间是相互独立的，但他们共享进程的所有资源，它们是处理器的执行单位，或者称为调度单位，它们就是线程
- 按照进程中线程数量划分，进程分为单线程进程和多线程进程，进程＝线程＋资源
- 由于各个进程都拥有自己的虚拟地址空间，正常情况下它们彼此无法访问到对方的内部，因为进程之间的安全性是由操作系统的分页机制保证的
- 一切执行流其实都是线程，因为任何时候进程中都至少存在一个线程

### 进程、线程的状态

- 操作系统把进程“执行过程”中所经历的不同阶段按状态归为几类。所谓执行过程，意为进程的状态描述的是进程中有关“动作”的执行流部分，即线程，而不包括静止的资源部分
- 等待外界条件的状态称为“阻塞态”，把外界条件成立时，进程可以随时准备运行的状态称为“就绪态”，把正在处理器上运行的状态称为“运行态”

### 进程PCB

- 操作系统为每个进程提供了一个PCB，Process Control Block，即程序控制块，用它来记录与此进程有关的信息，比如进程状态、PID、优先级等
- 每个进程都有自己的PCB，所有的PCB放到一张表格中维护，这就是进程表

## 在内核空间实现线程

- ABI,Application Binary Interface，应用程序二进制接口。在官方SysV_ABI_386中规定，位于Intel386硬件体系上的所有寄存器都具有全局性，因此在函数调用时，这些寄存器对主调函数和被调函数都可见。这5个寄存器ebp、ebx、edi、esi、esp归主调函数所用，因此被调函数不论是否使用这几个寄存器，都要为主调函数保护号这5个寄存器

## 双向链表

- 系统中有些数据是公共资源，对于它的修改应该保证原子操作。简单来说，访问公共资源的程序片段叫临界区，临界区通常是指在不同线程中的、修改同一公共资源的指令区域
- 位图操作要在关中断下进行

## 多线程调度

### 简单优先级调度基础

- 在就绪队列和全部队列中的结点并不是线程的PCB，而是线程PCB中的tag，即general_tag或all_list_tag
- 线程PCB在内存中的位置是散落的，由不同的链表将它们各自的general_tag和all_list_tag串联起来
- 就绪队列只存储准备运行的线程，“全部队列”存储所有线程。包括就绪的、阻塞的、正在执行的

### 任务调度器和任务切换

- 调度器主要任务就是读写就绪队列，增删里面的结点，结点是线程PCB中的general_tag

- 每发生一次时钟中断，时钟中断程序的处理程序便将当前运行线程的ticks减1

- 我们的调度机制很简单，就是Round-Robin Scheduling，俗称RR，即轮询调度，说白了就是让候选线程按顺序一个一个地执行，按照先进先出的顺序始终调度队头的线程

- 在线程调度的时候，如果只是时间片到了，就将其加入就绪队列尾

- 完整的程序分为两部分，一部分是做重要工作的内核级代码，另一部分就是做普通工作的用户级代码，所以，“完整的程序＝用户代码＋内核代码”。而这个完整的程序就是我们所说的任务，也就是线程或进程。

- 也就是说任务在执行过程中会执行用户代码和内核代码，当处理器处于低特权级下执行用户代码时，我们称之为用户态，当处理器进入高特权级执行到内核代码时，称之为内核态。因此一定要清楚，无论是执行用户代码，还是执行内核代码，这些代码都属于这个完整的程序，即属于当前任务，并不是说当前任务由用户态进入内核态后当前任务就切换成内核了

- 任务和任务的区别在于执行流一整套的上下文资源，这包括寄存器映像、地址空间、IO位图等。**因此处理器只有被新的上下文资源重新装载后，当前任务才被替换为新的任务，这才叫任务切换**

- 具体切换流程是：

  - 假设当前任务在中断发生前所处的执行流属于第一层，受时钟中断的影响，处理器会进入中断处理程序，这使当前的任务执行流第一次被改变，主要是保存任务的全部寄存器映像，也就是进入中断前任务所属第一层的状态，这些寄存器映像相当于任务中用户代码的上下文，在程序里这些寄存器是由kernel.S中定义的中断处理入口程序intr%1entry来保护的，当把这些寄存器映像恢复到处理器后，任务便完全退出中断，继续执行自己的代码部分

  - 之后在内核中执行中断处理程序，属于第二层的执行流。当中断处理程序调用任务切换函数时，当前中断处理程序又要被中断，因此要保护好第二层的上下文，即中断处理过程中的任务状态。这部分是保护内核环境的上下文，根据ABI，除esp外，只保护esi、edi、ebx、ebp这4个寄存器就够了，这4个寄存器映像相当于任务中的内核代码的上下文，保证顺利走到退出中断的出口，利用第一部分保护的寄存器环境彻底恢复任务

    

