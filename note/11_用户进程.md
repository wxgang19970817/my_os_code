# 11_用户进程

## 为什么要有任务状态段TSS

首先明确Linux任务切换未采用Intel的做法，而是用了一套自己的方法，只是用了TSS的一小部分功能

### 多任务的起源

- 软件的能力取决于硬件的支持。操作系统想实现某种功能，如果软件上的解决方式不好，或者干脆解决不了，就只能向CPU等硬件厂商提需求，让硬件一级直接支持，硬件厂商因此给硬件增加新的功能，从而使硬件得到了发展，软件(操作系统)便可以利用硬件的新功能，因此也变得更加强大，如此良性循环
- 起初CPU只支持单任务，后来随着多任务的需求越来越迫切，操作系统厂商和CPU厂商便开始构想多任务的方案了。硬件厂商为此提供了硬件解决方案，其中最主要的就是LDT和TSS

### LDT简介

- 按照内存分段的方式，内存中的程序映像自然被分为代码段、数据段等资源，这些资源属于程序私有部分，因此Intel建议，为每个程序单独赋予一个结构来存储其私有资源，这个结构就是LDT
- LDT是Local Descriptor Table的缩写，即局部描述符表，属于任务私有的结构，位置不固定。为了能找到它，需要将LDT在GDT注册后，利用选择子找到它
- CPU专门准备了个寄存器来存储LDT的位置和偏移量，就是LDTR

### TSS

- 明确单核CPU要想实现多任务，唯一的方案就是多个任务共享一个CPU，也就是只能让CPU在多个任务间轮转，让所有任务轮流使用CPU
- 任务的数据和指令是CPU的处理对象，任务的执行要占用一套存储资源，如寄存器和内存。内存中的数据往往被加载到高速的寄存器后再处理，处理完成后，再将结果回写到低速的内存中，所以，任何时候，寄存器中的内容才是任务的最新状态。采取轮流使用CPU的方式运行多任务，当前任务在被换下CPU时，任务的最新状态，也就是寄存器中的内容应该找个地方保存起来，以便下次重新将此任务调度到CPU上时可以恢复此任务的最新状态，这样任务才能继续执行
- 因此Intel将每个任务关联一个任务状态段TSS，用它来表示任务。TSS是由程序员“提供”：TSS是程序员为任务单独定义的一个结构体变量，由CPU来“维护”：CPU自动用此结构体变量保存任务的状态(任务的上下文环境、寄存器组的值)和自动从此结构体变量中载入任务的状态
- **任务切换的本质就是TSS的换来换去，也就是TR寄存器指向不同的TSS**
- 在CPU眼里为每个任务关联一个TSS,TSS就是任务的代表，在人类理解的任务切换就是让CPU执行不同任务的代码段中的指令，即使是所有任务共享一个TSS
- TSS描述符的TYPE字段中有一个B位，B为1时，表示任务繁忙。任务繁忙有两个方面的含义：一方面就是指此任务是否为当前正在CPU上运行的任务。另一方面是指此任务嵌套调用了新的任务，CPU正在执行新任务，此任务暂时挂起，等新任务执行完成后CPU会回到此任务继续执行
- 任务是不可重入的，也就是说当前任务只能调用其他任务，不能自己调用自己。CPU利用B位来判断被调用的任务是否是当前任务，被调用的任务的B位为1，这就表示当前任务自己在调用自己
- TSS同其他普通段一样，是位于内存的一段区域，其格式见drawio文件，TSS中的字段基本上全是寄存器名称，这些寄存器就是任务运行中的最新状态，可见TSS的主要任务就是保存任务的快照，也就是CPU执行该任务时，寄存器当时的瞬时值
- TSS中有三组栈，这三组栈是用来低特权级往高特权级跳转时用的，最低特权级是3，没有更低的特权级会跳入3特权级，因此没有SS3和esp3。而且对于这三组栈，不管进入高特权级后进行了多少次压栈操作，下次重新进入该特权级时，该特权级别的栈指针依然是TSS中最初的值，除非人为地在TSS中将栈指针改写。
- Linux只用到了0特权级和3特权级，所以我们只需要设置SS0和esp0的值就够了
- TR寄存器，ltr "16位通用寄存器"或"16位内存单元"，不管操作数是寄存器还是内存，其值必须是描述符在GDT中的选择子

### 现代操作系统采用的任务切换方式

- 不仅Linux未采用任务单独关联TSS的任务切换方法，而且几乎所有x86操作系统都未采用
- 我们使用TSS唯一的理由是为0特权级的任务提供栈，需要提前在TSS中写入
- Linux为每个CPU创建一个TSS，在各个CPU上的所有任务共享同一个TSS，各CPU的TR寄存器保存各CPU上的TSS，在用ltr指令加载TSS后，该TR寄存器永远指向同一个TSS，之后再也不会重新加载TSS。在进程切换时，只需要把TSS中的SS0及esp0更新为新任务的内核栈的段地址及栈指针

## 实现用户进程

### 实现用户进程的原理

- 进程与内核线程最大的区别是进程有单独的4GB空间
- 在TSS中记录的0特权级栈指向PCB页面的最顶端
- 要为每个进程单独申请存储页目录项及页表项的虚拟内存页
- 用户进程在特权级3下工作，因此我们还要为用户进程创建在3特权级的栈，栈也是内存区域，自然也要为进程分配内存作为3级栈空间
- 进入特权级3的要点：
  1. 任务的上下文信息被保存在任务pcb中的中断栈中，从中断返回必须经过inte_exit
  2. 提前在用户进程的栈中装填好用户进程的上下文信息，借助一系列的pop出栈，将用户进程的上下文信息载入CPU的寄存器
  3. 在栈中存储的CS选择子，其rpl必须为3
  4. 栈中段寄存器的选择子必须指向DPL为3的内存段
  5. 对于可屏蔽中断来说，任务之所以能进入中断，是因为标志寄存器eflags中的IF位为1,所以要保证栈里的eflags也是如此
  6. 用户进程属于最低的特权级，对于IO操作，不允许用户进程直接访问硬件，只允许操作系统有直接的硬件控制，这是由eflags中的IOPL位决定的，必须使其值为0

### 用户进程的创建流程

- 创建进程的函数会先调用和创建线程一样的函数，先在内核申请一页用作PCB，然后初始化thread_struct，大部分初始化和内核线程初始化一致。但是因为用户进程有自己的4GB空间，所以初始化的时候要初始化好页表和虚拟地址位图。
- 先说页表，用户进程也需要访问到内核，所以我们每次创建一个新的用户进程，就将内核页目录项复制到用户进程页目录表中同等位置，其次要把用户页目录表中最后一个页目录项更新为用户进程自己的页目录表的物理地址，页目录表所在的页是在内核空间中申请的
- 用户进程的4GB虚拟地址空间，除了存放用户进程自己的指令和数据外，还要包括用户进程自己的堆和栈。用户进程可以在自己的堆中申请、释放内存，因此必须用位图来管理跟踪地址分配情况。为了实现堆内存管理，由用户进程自己的虚拟内存池统一管理。需要管理的虚拟内存大概是上到除去内核占据的1G的3G顶端，下到程序的入口地址0x804800(这个地址是静态链接之后编译器给出的程序的入口地址)
- 然后就是thread_create函数，位于PCB顶端的内核栈指针会向下空出中断栈和内核栈的空间，最终指向内核栈底端。然后用eip挂载了start_process函数，该函数用来构建用户进程的上下文
- 将中断栈的各种寄存器环境填充好，最后跳转到中断退出程序，就可以执行想执行的程序了
  - 用户进程在执行前，是由操作系统的程序加载器将用户程序从文件系统读到内存，再根据程序文件的格式解析其内容，将程序中的段展开到相应的内存地址。程序格式中会记录程序的入口地址，CPU把CS:IP指向它，该程序就被执行了。

- 用户进程有自己的4GB空间，所以页目录表是必不可少的，前面只进行了相关分析，现在我们要申请一页用来做页目录表。而关键点在于用户的页目录表是不能让用户直接访问到的，所以要在内核空间内申请。
- 目前咱们的线程并不是为用户进程服务的，它是为内核服务的因此与内核共享同一地址空间，也就是和内核用的是同一套页表。正常来讲，进程和线程都是独立的执行流，它们有各自的栈和页表，只不过线程的页表是和其他线程共用的，而进程的页表是单独的。进程和线程在被中断信号打断时，要考虑页表的切换，重新在页表寄存器CR3中加载新的页表

### 总结

**用户进程的特点**：

- 3特权级，在中断栈中构建进程环境的时候，各个段的选择子都是3级
- 自己单独的页表(页表加页目录表)，但是是在内核空间申请的，因为不能被用户进程访问到
- 有3特权级栈，这个栈的虚拟地址是在高1G的内核空间一下，实际的物理地址是在32MB剩余空间一分为二的其中之一的用户空间内

## BSS

### Linux下C程序的布局

- 用户程序内存空间的最顶端用来**存储命令行参数及环境变量**，这些内容是由操作系统下的C运行库写进去的，将来实现从文件系统加载用户进程并为其传递函数的时候会用到

- 紧接着是用户进程的栈空间和堆空间，栈向下扩展，堆向上扩展，栈和堆在空间上是相接的，这两个空间由操作系统管理分配。由于栈与堆是相向扩展的，操作系统需要检测栈和堆的碰撞，因此在加载之初，操作系统必须为堆和栈分别指定起始地址

- 最下面是未初始化数据段BSS、初始化数据段data及代码段text由链接器和编译器负责。链接器把目标文件中的属性相同的节合并到一起，这样操作系统便可统一为其分配内存了。按照属性来划分节，大致上有三种类型：

  - 可读写的数据，如数据节.data和未初始化节.bss
  - 只读可执行的代码，如代码节.text和初始化代码.init
  - 只读数据，如只读数据节.rodata，一般情况下字符串就存储在此节

  链接器把目标文件中相同属性的节归并之后的节的集合，便称为segment，它存在于二进制可执行文件中，也就是C程序运行时内存空间中分布的代码段、数据段等段

### BSS段

- BSS段中是未初始化的全局变量和局部静态变量。未运行之前或运行之初，程序中bss中的内容都是未初始化的数据，它们也是变量，不过这些变量的值最初时是多少都无所谓，它们的意义是在运行过程中才产生的，故程序文件中无需存在bss实体，因此不占用文件大小，仅在elf头中有bss节的虚拟地址、大小等相关记录。在程序运行后那些位于bss中的未初始化数据便被赋予了有意义的值，那时bss开始变得有意义了，故bss仅存在于内存中。
- 对于这种只占内存又不占文件系统空间的数据，链接器采取了合理的做法：由于bss中的内容是变量，其属性是可读写，这和数据段属性一致，故链接器将bss占用的内存空间大小合并到数据段占用的内存中。

