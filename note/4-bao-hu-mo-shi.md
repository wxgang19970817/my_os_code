---
description: 配套代码：v0.4
---

# 4\_保护模式

### 实模式的缺点

1. 实模式下操作系统和用户程序属于同一特权级
2. 用户程序所引用的地址都是指向真实的物理地址
3. 用户程序可以自由修改段基址
4. 访问超过64KB的内存区域时要切换段基址，麻烦
5. 一次只能运行一个程序，无法充分利用资源
6. 共20条地址，最大可用内存为1M，太小了

### 保护模式的变化

* 保护模式运行在32位之下，地址总线和数据总线也发展到32位，其寻址空间也达到了2的32次方，4GB
* **除段寄存器外**，通用寄存器、指令指针寄存器、标志寄存器都由原来的16位扩展到了32位
* 访存方式依然是“段基址：段内偏移”，但是为了更加安全，要给段基址添加一些约束条件，这些约束条件就是内存段的描述信息，称之为**段描述符**，一个段寄存器肯定是放不下，所以要存放在全局描述符表中。由此段寄存器中保存的再不是段基址了，而叫“选择子”，该选择子用来索引全局描述符表中的段描述符
  * 全局描述符表的地址存放在GDTR中
  * 首先来讲，全局描述符表是在内存中，访问内存肯定是比访问寄存器要慢，其次段描述符(64字节)内的信息比较零散，要从中拼合出有用的信息，也需要花时间。现在发展出保护模式带来了这两个缺点，肯定是要解决掉的，不然怎么能算进步
  * 所以为了提高获取短信息的效率，对段寄存器率先应用了缓冲技术，将段信息用一个寄存器来缓存，即段描述符缓冲寄存器。CPU会将从内存中获得的信息，整理完后存入段描述符缓冲寄存器，以后每次访问相同的段时，直接读取该段寄存器
  * 那么此信息何时失效呢？在保护模式下每次加载选择子(即使新选择子的值和之前段寄存器中老的选择子相同)，CPU就会重新访问全局描述符表，再将获取的段信息存入段描述符缓冲寄存器
* 可以开启分页基址，由编译器编译出的线性地址是连续的，开启分页后，物理地址可以不连续

－－－学习的时候可以将第一点和第二点对比学习，保护模式的出现就是就是为了解决实模式的缺点－－

## 进入保护模式三步走：

### 全局描述符表

* **段描述符**：描述符占连续的8字节，格式图见drawio文件
  * 段基址是32位
  * 段界限表示段边界的扩展最值，20位，单位要么是字节要么是4KB，取决于G位
  * G位：0表示段界限粒度大小为1字节，1表示段界限粒度大小为4KB字节
  * S位：0表示该段是系统段，在cpu眼里凡是硬件运行需要用到的东西都是系统；1表示数据段，在cpu眼里凡是软件(操作系统也属于软件)需要的东西都称为数据，无论是代码，还是数据甚至包括栈
  * TYPE位：4位组成，用于表示内存段或门的子类型，比如非系统段里可细分是否可执行、是否可读、是否是一致性代码等属性
  * DPL位：表示描述符特权级，由于段描述符用来描述一个内存段或门(一段代码)的情况，所以描述符中的DPL代表的是内存段的特权级。CPU进入保护模式后，特权级自动为0
  * P位：1表示段存在于内存中，0表示段不存在于内存中，CPU将抛出异常，转到相应的异常处理程序
  * 其余位不用特别关注
* **全局描述符表GDT**
  * 全局描述符表位于内存中，需要用专门的寄存器GDTR指向它后，CPU才知道它在哪里
  * 加载的指令是:lgdt48位内存数据，前16位是GDT以字节为单位的界限值，后32位是GDT的起始地址
  * GDT的大小是16位二进制，即65535字节，每个描述符大小是8字节，故GDT中最多可容纳的描述符数量是65535/8=8192个
  * 注意：现在还没有进入保护模式，进入保护模式的必要条件就是加载GDT,目前在实模式下构造GDT只能放在1M空间下，但是在进入保护模式后，GDT的位置可能会突破1M空间的限制，到时候需要重新加载
* **选择子**
  * 段寄存器是16位，所以选择子也是16位，在其低2位0\~1用来存储RPL，即请求特权级，可以表示0、1、2、3四种特权级，第2位是TI位，用来指示选择子是在GDT中还是在LDT中索引描述符，剩下13位用来在GDT中索引段描述符，2的13次正好是8192个，结构图见drawio文件
  * 值得一提的是在GDT中第0个段描述符是不可用的，原因是GDT中的段描述符要用选择子来访问，如果使用的选择子忘记初始化，选择子的值便会是0，这便会访问到第0个描述符，处理器会发出异常。

### 打开A20地址线

*





****

### 冷知识

* 保护模式是在Intel80286CPU中首次出现的，这是继8086之后，Intel紧接着推出的一款产品
