---
description: 配套代码：v0.4
---

# 4\_保护模式

### 实模式的缺点

1. 实模式下操作系统和用户程序属于同一特权级
2. 用户程序所引用的地址都是指向真实的物理地址
3. 用户程序可以自由修改段基址
4. 访问超过64KB的内存区域时要切换段基址，麻烦
5. 一次只能运行一个程序，无法充分利用资源
6. 共20条地址，最大可用内存为1M，太小了

### 保护模式的变化

* 保护模式运行在32位之下，地址总线和数据总线也发展到32位，其寻址空间也达到了2的32次方，4GB
* **除段寄存器外**，通用寄存器、指令指针寄存器、标志寄存器都由原来的16位扩展到了32位
* 访存方式依然是“段基址：段内偏移”，但是为了更加安全，要给段基址添加一些约束条件，这些约束条件就是内存段的描述信息，称之为**段描述符**，一个段寄存器肯定是放不下，所以要存放在全局描述符表中。由此段寄存器中保存的再不是段基址了，而叫“选择子”，该选择子用来索引全局描述符表中的段描述符
  * 全局描述符表的地址存放在GDTR中
  * 首先来讲，全局描述符表是在内存中，访问内存肯定是比访问寄存器要慢，其次段描述符(64字节)内的信息比较零散，要从中拼合出有用的信息，也需要花时间。现在发展出保护模式带来了这两个缺点，肯定是要解决掉的，不然怎么能算进步
  * 所以为了提高获取短信息的效率，对段寄存器率先应用了缓冲技术，将段信息用一个寄存器来缓存，即段描述符缓冲寄存器。CPU会将从内存中获得的信息，整理完后存入段描述符缓冲寄存器，以后每次访问相同的段时，直接读取该段寄存器
  * 那么此信息何时失效呢？在保护模式下每次加载选择子(即使新选择子的值和之前段寄存器中老的选择子相同)，CPU就会重新访问全局描述符表，再将获取的段信息存入段描述符缓冲寄存器
* 可以开启分页基址，由编译器编译出的线性地址是连续的，开启分页后，物理地址可以不连续

－－－学习的时候可以将第一点和第二点对比学习，保护模式的出现就是就是为了解决实模式的缺点－－

### 全局描述符表

*   **段描述符**：描述符占连续的8字节，格式图见drawio文件

    * 段基址是32位
    * 段界限表示段边界的扩展最值，20位，单位要么是字节要么是4KB，取决于G位
    * G位：0表示段界限粒度大小为1字节，1表示段界限粒度大小为4KB字节
    * S位：0表示该段是系统段，在cpu眼里凡是硬件运行需要用到的东西都是系统；1表示数据段，在cpu眼里凡是软件(操作系统也属于软件)需要的东西都称为数据，无论是代码，还是数据甚至包括栈
    * TYPE位：4位组成，用于表示内存段或门的子类型，比如非系统段里可细分是否可执行、是否可读、是否是一致性代码等属性
    * DPL位：表示描述符特权级，由于段描述符用来描述一个内存段或门(一段代码)的情况，所以描述符中的DPL代表的是内存段的特权级。CPU进入保护模式后，特权级自动为0
    * P位：1表示段存在于内存中，0表示段不存在于内存中，CPU将抛出异常，转到相应的异常处理程序
    * 其余位不用特别关注



****

### 冷知识

* 保护模式是在Intel80286CPU中首次出现的，这是继8086之后，Intel紧接着推出的一款产品
