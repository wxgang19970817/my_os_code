# 8_内存管理系统

## makefile

### makefie是什么

- 通常一个大型程序是由多个程序模块文件构成的，按照其功能划分，模块文件会分布在不同的目录中。模块文件之间有包含头文件、调用函数的情况，它们之间存在依赖关系。大多数情况下，我们编写程序只是修改了某些文件，肯定不是同时更新所有文件，按理说只要把那些有过改动的文件，并且依赖于这些文件的相关文件编译即可
- Linux提供了make命令，它可以帮助我们自动找出变更的文件，并根据依赖关系，找出受变更文件影响的其他相关文件，然后对这些文件按照规则进行单独处理
- 上述的规则和依赖关系是定义在文件makefile中，make程序通过解析makefile文件，自动找出变更的文件以及依赖此变更文件的相关文件，然后对所有受影响的相关文件执行事先定义好的命令规则

### makefile基本语法

- **基本语法：**

  > 目标文件：依赖文件
  >
  > [Tab]命令

  - 目标文件是指此规则中想要生成的文件，可以是.o结尾的目标文件，也可以是可执行文件，也可以是个伪目标
  - 依赖文件是指要生成此规则中的目标文件，需要哪些文件。通常依赖文件不是1个，所以此处是个依赖文件的列表
  - 命令是值此规则中要执行的动作，这些动作是指各种shell命令。命令可以有多个，但一个命令要单独占用一行，在行首必须以Tab开头
  - “目标”和“依赖文件列表”之间的冒号不可少

- make是如何判断文件有更新的？
  - 在Linux中，文件分为属性和数据两部分，每个文件有三种时间，分别用于记录与文件属性和文件数据相关的时间，这三个时间分别是：
    - atime:访问文件数据部分的时间
    - ctime:表示文件属性或数据的改变时间
    - mtime:表示文件数据部分的修改时间，每次文件的属性和数据被修改时就会更新mtime
    - 对于文件来说，我们主要关注的是其数据部分，所以只要make程序分别获取依赖文件和目标文件的mtime，对比依赖文件的mtime是否比目标文件的mtime新，就知道是否要执行规则的命令

- make文件名
  - makefile的文件名也并非固定，可以在执行make时用-f参数指定，如果未用-f指定，默认情况下，make会先去找名为GNUmakefile的文件，若该文件不存在，再去找名为makefile的文件，若makefile文件不存在，最后会去找名为Makefile的文件

- 跳到目标处执行
  - makefile中有很多目标时，我们可以用目标名称作为make的参数，采用“make 目标名称”的方式，单独执行目标名称处的规则，执行完就会退出，后面即使存在其他目标也不会执行

- 伪目标
  - 有时候我们希望make不要考虑mtime，而是总能去执行一些命令
  - make 规定，当规则中不存在依赖文件时，这个目标文件名就称为－－伪目标，不产生真实的目标文件，只管执行伪目标规则中的命令
  - 伪目标不能和真实目标文件同名，可以用关键字".PHONY"来修饰伪目标，格式为".PHONY:伪目标名"
  - 通常需要显式用.PHONY修饰伪目标的场合是删除编译过程中的.o文件

- make:递归式推导目标
  - 在makefile中的目标，是以递归的方式逐层向上查找目标的

- 自定义变量与系统变量
  - 变量定义的格式：变量名＝值(字符串)，多个值之间用空格分开。make程序在处理时会用空格将值打散，然后遍历每一个值
  - 值仅支持字符串类型，即使是数字也被当做字符串来处理
  - 变量引用格式：$(变量名)，每次引用变量时，变量名就会被其值(字符串)替换
  - 虽然变量的值会被当做字符串类型处理，但不能将其用双引号或单引号括起来，否则引号会被当作变量值的一部分
  - 除了用户自定义的变量外，make还自行定义了一些系统级的变量，按其用途可分为命令相关的变量及参数相关的变量，如：AR、CC、CFLAGS等等

- 隐含规则
  - 在编写规则时，若一行写不下，可以在行尾添加反斜杠字符“\”，这样下一行的内容便被认为是同一行
  - makefile中用#来注释
  - 对于一些使用频率非常高的规则，make把它们当成是默认的，不需要显式地写出来，当用户未在makefile中显式定义规则，将默认使用隐含规则进行推导
  - 隐含规则只限于那些编译过程中基本固定的依赖关系，比如C语言代码文件扩展名.c，编译生成的目标文件扩展名是.o，这一般是一对一的。而一个可执行程序可能是由多个.o文件共同链接生成的，所以这种不确定性无法使之成为隐含的规则
  - 隐含规则是用系统变量来实现的

- 自动化变量
  - $@,表示规则中的目标文件集合，如果存在多个目标文件，$@则表示其中每一个文件名
  - $<，表示规则中依赖文件中的第1个文件
  - $^，表示规则中所有依赖文件的集合
  - $?，表示规则中，所有比目标文件mtime更新的依赖文件集合

- 模式规则
  - 模式，正则表达式中用此概念表示字符或字符串匹配，把符合此模子的字符串找出来
  - %用来匹配任意多个非空字符，比如%.o代表所有以.o为结尾的文件，g％s.o是以字符g开头的所有以.o为结尾的文件

## 实现assert断言

- 在系统中实现了两种断言，一种是为内核系统使用的ASSERT，另一种是为用户进程使用的assert，此处要留意，建议提前到用户进程那一章做好标记，因为作者并没有在用户进程处提到断言的事，而直接在程序中更改了代码，而且基本上等到读者做到用户进程那一章，间隔太久，容易遗忘。做好标记，会避免不必要的麻烦

- ```assembly
  #define PANIC(...) panic_spin (__FILE__,__LINE__,__func__,__VA_ARGS)
  ```

  - PANIC后面是(...)，括号中应该是形参，这是C预处理器支持的一种用法，它允许宏支持个数不固定的参数，预处理器为此专门提供了一个标识符__VA_ARGS__，它只允许可变参数的宏替换列表出现，该参数至少有一个，但可以为空
  - _ _ FILE _ _ , _ _ LINE _ _ ，_ _ func _ _，这三个是预定义的宏，分别表示被编译的文件名，被编译文件中的行号，被编译的函数名。当时很好奇是如何实现的？其实这些都是编译器内置的宏，ANSI C标准中几个标准预定义的宏，会将想要的文件名、行号等在宏的位置插入

## 位图bitmap

### 位图简介

- 位是bit，即字节中的位，1字节中有8个位。图是指map，本质上是映射的意思，综合起来就是用字节中的1位来映射其他单位大小的资源
- 管理结构中的数据也有自己的单位大小，被管理的资源也有自己的单位大小，故有效减少管理成本的方法是使管理结构中的单位达到最小，其所管理资源的单位调整到最大
- 现在用位图来管理内存，位图中的每一位都将表示实际物理内存中的4KB，也就是一页，即位图中的一位对应物理内存中的一页，如果为0，表示该位对应的页未分配

### 位图的定义和实现

- 关于位图的长度：位图的大小取决于所管理的资源的大小，其长度不固定。所以在程序中的解决办法就是：用指针来记录位图的起始地址

## 内存管理系统

### 内存地址池的规划

- 内存地址池：将可用的内存地址集中放到一个“池子”中，需要的时候直接取出，用完再放回去
- 内存池的分配：　我们把物理内存分成两个内存池，一部分称为用户物理内存池，内存池的物理内存用来分配给用户进程，当用户内存池中的内存都被用户进程耗尽时，不再向内核内存池申请，而是返回“内存不足”；另一部分就是内核物理池，此内存池中的物理内存只给操作系统用
- 虚拟内存地址池：在32位环境下，虚拟地址空间为4GB，除了地址空间比较大以外，分页机制的另一个好处是每个任务都有自己的4GB虚拟地址空间，也就是各程序中的虚拟地址不会与其他程序冲突，都可以为相同的虚拟地址。**程序中的地址是由链接器在链接过程中分配的，分配过后就不会再变了。**程序在运行过程中也有申请内存的需求，这种动态申请内存一般是指在堆中申请内存，找个空闲的虚拟地址和物理地址并建立映射。
- 内核起始是可以不通过内存管理系统申请内存的，直接拿来用，但是这里我们为了方便管理也让内核从内核物理内存池中分配内存，然后在内核自己的页表建立映射
- 对于用户物理池，是所有进程共享一个物理池，而物理和虚拟的映射关系是保存在每个进程自己的页表中的
- 进程PCB或者线程TCB要占用1页内存，不能跨页占用
- 一般的内存管理系统所管理的是那些空闲的内存，内存管理相关数据结构所占的内存不需要被管理

### 代码

- 在内存池申请内存的原理：先在虚拟内存池中申请可用的虚拟地址，然后在物理内存池中申请物理页，然后在页表中完成映射。所谓在页表中映射其实就是该新建页目录项就新建页目录项，该新建页表项就新建页表项，将其申请到的物理地址存入虚拟地址索引到的页表项里



