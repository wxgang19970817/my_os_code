# 0\_一些可能迷惑的问题

### 访问硬件的两种方式：

* 将硬件某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，比如显卡的显存
* 外设是通过IO接口与CPU通信的，CPU访问外设就是访问IO接口，其实就是访问接口里的寄存器

### 内核态和用户态

* 用户态和内核态不是对用户进程来讲的，而是指cpu运行在用户态(特权级3)和内核态(特权级0)
* 用户进程陷入内核态：由于内部或外部中断发生时，当前进程被暂停执行，其上下文被内核中断程序保存起来，开始执行一段**内核**的代码。此时执行的内核的代码，用户代码已经下了cpu

### 内存访问为什么要分段

* 首先是为了重定位，不分段的时候访问存储单元要使用物理地址，分段之后可以将程序指令中的地址改成另一个地址，但保证内容还是原来的内容。
* 其次是因为16位的地址总线能访问的空间是64KB，而改为”段基址＋段内偏移地址“访问的话，可寻址空间就变为了20位，1MB的大小

### 内存访问机制的段和程序的分段一样嘛

* 其实本质上是一回事，内存分段指的是处理器为访问内存而采用的机制，程序分段是软件中逻辑划分的内存区域，本身也是一段内存，所以处理器在访问该区域的时候，也会采用内存分段机制，用段寄存器指向该区域的起始地址

### 物理地址、逻辑地址、有效地址、线性地址、虚拟地址

* **物理地址**：CPU最终访问物理内存时采用的地址，具有唯一性
* **线性地址：**在保护模式下，段选择子＋段内偏移地址组合起来的地址，如果未开启分页模式，该地址就被当作物理地址使用
* **虚拟地址**：在保护模式下。开启了分页模式后线性地址又被称为虚拟地址，虚拟地址经过页部件转换成具体的物理地址去访问
* **有效地址和逻辑地址**：无论是在实模式还是保护模式下，段内偏移地址被称为有效地址或逻辑地址，是程序员可见的地址
* 线性地址或称虚拟地址，不是真实的地址，是用来在32位系统保护模式下用来描述4GB的寻址空间

### 平坦模型和多段模型

* 平坦模型就是相对于多段模型来说的。平坦模型只有一个段，在保护模式下，由于地址总线达到了32位，因此只需要一个段就可以访问到4GB的空间

### 局部变量和函数参数为什么要放在栈中

* 通俗来讲，全局变量意味着任何人随时随地都要访问，所以才要放到数据段中，而局部变量和函数参数只是自己在用，放在数据段中纯属浪费空间，所以将其放在自己的栈中，随时可以清理，体现了局部的原理
* 另外对于函数的参数，因为函数是执行过程中被调用的，编译时无法预测会何时调用以及被调用的次数，其参数和函数的返回地址也要内存来存储，所以也不知道会需要多少内存，所以只能在每次调用函数的时候动态为其分配内存

### 编译器GCC是C语言编写的

### 大小端字节序

* 小端字节序：数值的低字节存放在内存的低地址，好处在于强制转换数据类型时不需要在调整字节了，目前是x86、DEC采用
* 大端字节序：数值的低字节存放在内存的高地址，好处在于比较符合人类的阅读习惯，目前是IBM、Sun、PowerPC采用
* ARM体系的CPU则大小端字节序通吃

### **BIOS中断、DOS中断、Linux中断**

* BIOS和DOS都是存在于实模式下的程序，通过软中断指令int中断号在中断向量表IVT中查找中断向量，中断向量描述了中断处理程序的地址
* BIOS和DOS的中断号不同，DOS只用了一个0x21这个中断号
* Linux内核是在进入保护模式后才建立的中断例程，中断向量表被中段描述符表所代替，通过int 0x80指令进入中断程序后，根据eax寄存器的值来调用不同的子功能函数

### section和segment

* **section**:节，在汇编源码中经由关键字section和segment修饰、逻辑划分的指令或数据区域，诞生于编译过程的目标文件
* **segment**:段，链接器根据目标文件中属性相同的多个section合并后的section集合，诞生于链接过程中的可执行文件

### CPU的下一条指令

* 对于pc这个概念，它只是cpu中有关下一条指令存放地址的统称，不同的CPU体系结构有不同的解读，在x86中是cs:ip，在ARM中是pc
* CS:IP不能直接用mov指令去改变，有专门的改变指令流的的指令，如jmp、call、int、ret
* ARM中可以用mov指令来修改

### 指令集、微架构、交叉编译

* 指令格式：规定操作码和操作数的大小和位置，然后在CPU硬件电路中写死这些规则，让CPU在硬件一级上识别这些格式，从而能识别出操作码和操作数
* **指令集**：指令集是一套约定，里面规定的是有哪些指令、指令的二进制编码、指令格式，如何实现这套约定是硬件自己的事儿,一种CPU只能识别一种指令集
* **微架构：**指的就是指令集的物理实现方式
* **交叉编译**：本质上就是用在A体系结构上运行的编译器，编译出符合B体系结构CPU指令集的程序，编译出的程序能直接在B体系结构上运行

### 库函数是用户进程和内核的桥梁

* 头文件中可以写任何内容，甚至是函数体
* 函数一定要有函数体才能被调用，必须有相应的函数实现
* 头文件中的函数声明告诉编译器：
  * 函数的返回值类型、参数类型及个数，用来确定分配的栈空间
  * 该函数是外部函数，定义在其他文件，需要链接阶段将该函数体所在的目标文件一同链接重定位分配地址
* C运行时库：程序在运行时所需要的库，由众多可复用的函数文件组成，由编译器提供

